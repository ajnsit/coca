/* This module defines standard operations that are always available.

   Some types and operations are required to be defined for the compiler
   to work correctly (i.e. types like `:int` or `:list`)
*/
module std/core
infixr 80 (^)
infixl 70 (*)
infixl 70 (%)
infixl 70 (/)
infixl 70 cdiv
infixl 70 cmod
infixl 60 (+)
infixl 60 (-)
infix 40 (!=)
infix 40 (==)
infix 40 (<=)
infix 40 (>=)
infix 40 (<)
infix 40 (>)
infixr 30 (&&)
infixr 20 (||)
// The unit type `:()` is inhabited by just a single value, namely `()`.
// See also the `:void` type and the `:bool` type.
type () {
  // The unit type `:()` is inhabited by just a single value, namely `()`.
// See also the `:void` type and the `:bool` type.
  con () : ();
};
// The exception effect: a partial function may raise an exception.
type exn :: X ;
// The divergence effect: a divergent function may not terminate.
type div :: X ;
// The alloc effect signifies a function may allocate in a heap `:h`
type alloc <(h :: H)> :: H -> X ;
// The read effect: signifies that a function may read from from heap `:h`.
type read <(h :: H)> :: H -> X ;
// The write effect: signifies that a function may write to heap `:h`.
type write <(h :: H)> :: H -> X ;
// The _total_ effect represents the absence of any effect.
type <> :: E ;
// The effect constructor extends an effect with another effect.
type <|> <(a :: X),(e :: E)> :: (X, E) -> E ;
// Stateful funs can manipulate heap `:h` using allocations, reads and writes.
alias st<(h :: H)> :: H -> E = <(read :: H -> X)<(h :: H)>,(write :: H -> X)<(h :: H)>,(alloc :: H -> X)<(h :: H)>> = 1;
// The `:ui` effect signifies a function may access the graphics system
type ui :: X ;
// The `:net` effect signifies a function may access the network
type net :: X ;
// The console effect signifies that a function may read or write to the console.
type console :: X ;
// The `:file` effect signifies a function may access the file system
type file :: X ;
// The `:global` heap is a special heap constant to denote the global shared heap
type global :: H ;
// NonDeterminism: a nonDeterministic function may return varying
// results even when called with the same input values.
type ndet :: X ;
// The `:io-total` effect is used for functions that perform arbitrary I/O operations, but are terminating without raising exceptions.
alias io-total :: E = <(ndet :: X),(console :: X),(net :: X),(file :: X),(ui :: X),((st :: H -> E)<(global :: H)> == 1 <(read :: H -> X)<(global :: H)>,(write :: H -> X)<(global :: H)>,(alloc :: H -> X)<(global :: H)>>)> = 2;
// The `:io-noexn` effect is used for functions that perform arbitrary I/O operations, but raise no exceptions
alias io-noexn :: E = <(div :: X),((io-total :: E) == 2 <(ndet :: X),(console :: X),(net :: X),(file :: X),(ui :: X),((st :: H -> E)<(global :: H)> == 1 <(read :: H -> X)<(global :: H)>,(write :: H -> X)<(global :: H)>,(alloc :: H -> X)<(global :: H)>>)>)> = 3;
// The `:io` effect is used for functions that perform arbitrary I/O operations.
alias io :: E = <(exn :: X),((io-noexn :: E) == 3 <(div :: X),((io-total :: E) == 2 <(ndet :: X),(console :: X),(net :: X),(file :: X),(ui :: X),((st :: H -> E)<(global :: H)> == 1 <(read :: H -> X)<(global :: H)>,(write :: H -> X)<(global :: H)>,(alloc :: H -> X)<(global :: H)>>)>)>)> = 4;
// A pair of values `:a` and `:b`.
type (,) <a,b> :: (V, V) -> V {
  // A pair of values `:a` and `:b`.
  con (,)(fst: a, snd: b) : forall<a,b> (fst : a, snd : b) -> (a, b);
};
// An any type. Used for extern calls
type any ;
// An arbitrary precision signed integer.
type int ;
// A reference `:ref<h,a>` points to a value of type `:a` in heap `:h`.
type ref <(h :: H),a> :: (H, V) -> V ;
// Exceptions
type exception ;
// A `:try` type represents a first-class exception result.
type try <a> :: V -> V {
  con Exn(exception: exception) : forall<a> (exception : exception) -> (try :: V -> V)<a>;
  con Ok(result: a) : forall<a> (result : a) -> (try :: V -> V)<a>;
};
// Yield alias
alias yld<a> :: V -> V = a = 1;
// A triple of values.
type (,,) <a,b,c> :: (V, V, V) -> V {
  // A triple of values.
  con (,,)(fst: a, snd: b, thd: c) : forall<a,b,c> (fst : a, snd : b, thd : c) -> (a, b, c);
};
// A quadruple of values.
type (,,,) <a,b,c,d> :: (V, V, V, V) -> V {
  // A quadruple of values.
  con (,,,)(fst: a, snd: b, thd: c, field4: d) : forall<a,b,c,d> (fst : a, snd : b, thd : c, field4 : d) -> (a, b, c, d);
};
// A quintuple of values.
type (,,,,) <a,b,c,d,a1> :: (V, V, V, V, V) -> V {
  // A quintuple of values.
  con (,,,,)(fst: a, snd: b, thd: c, field4: d, field5: a1) : forall<a,b,c,d,a1> (fst : a, snd : b, thd : c, field4 : d, field5 : a1) -> (a, b, c, d, a1);
};
// The `:blocking` effect signifies that a function may block
type blocking :: X ;
// The type of booleans has two inhabitants: `True` and `False`.
type bool {
  con False : bool;
  con True : bool;
};
// A unicode character.
// Characters are unicode _codepoint_\/s.
// This is different from a unicode _grapheme_ which represents a single displayed
// symbol and can consists of multiple codepoints due to combining characters and marks.
// (see also the [``std/text/unicode``](std_text_unicode.html) module.)
type char ;
// The choice type represents one of two possible types `:a` or `:b`.
type either <a,b> :: (V, V) -> V {
  con Left(left: a) : forall<a,b> (left : a) -> (either :: (V, V) -> V)<a,b>;
  con Right(right: b) : forall<a,b> (right : b) -> (either :: (V, V) -> V)<a,b>;
};
// Delayed (or _lazy_) values are computed (with effect `:e`) only the first time
// `force` is called and cached afterwards.
type delayed <(e :: E),a> :: (E, V) -> V {
  
};
// A 64-bit IEEE 754 floating point value.
// See also `std/num/double` for more operations on `:double`s.
type double ;
// The predicate `:ediv<x,a,e>` signifies that if the type `:a` contains a reference to effect constant `:x",
// then the effect `:e` must contain the divergent effect (`:div`). This constraint is generated
// for operations on first-class effects where code can diverge through operations.
type ediv <(a :: X),b,(e :: E)> :: (X, V, E) -> P ;
// A string is a sequence of unicode character points (`char`).
// The encoding of a string is internal and there
// is no constant-time indexing of characters in a string.
// Use the `:sslice` type for efficient matching and retrieving
// sub-strings from string.\
// See also the [``std/text/string``](std_text_string.html) module.
type string ;
type open exception-info {
  con Error : exception-info;
  con Assert : exception-info;
  con Todo : exception-info;
  con Range : exception-info;
  con Finalize : exception-info;
  con Pattern(location: string, definition: string) : (location : string, definition : string) -> exception-info;
  con System(errno: string) : (errno : string) -> exception-info;
  con Internal(name: string) : (name : string) -> exception-info;
};
// The `:global-scope` is a special type constant to denote the global scope
type global-scope :: S ;
// Handled effects are lifted to an atomic effect using the `:handled` type constructor
type handled <(a :: HX)> :: HX -> X ;
// Linear effects are lifted to an atomic effect using the `:handled1` type constructor
type handled1 <(a :: HX1)> :: HX1 -> X ;
type handler-branch0 <(e :: E),a> :: (E, V) -> V ;
type handler-branch1 <(e :: E),a,b> :: (E, V, V) -> V ;
// The predicate `:hdiv<h,a,e>` signifies that if the type `:a` contains a reference to `:h`,
// then the effect `:e` must contain the divergent effect (`:div`). This constraint is generated
// when writing to the heap (see `(!)`) and is necessary to catch cases where code can diverge
// by storing self referential functions in the heap.
type hdiv <(h :: H),a,(e :: E)> :: (H, V, E) -> P ;
;
// The type of lists, which can be either empty (`Nil`) or an element followed
// by a list (`Cons`).
type rec list <a> :: V -> V {
  // The empty list.
  con Nil : forall<a> (list :: V -> V)<a>;
  // A ``head``  element followed by the ``tail``  of the list.
  con Cons(head: a, tail: (list :: V -> V)<a>) : forall<a> (head : a, tail : (list :: V -> V)<a>) -> (list :: V -> V)<a>;
};
// The `:maybe` type is used to represent either a value (`Just(x)`) or `Nothing`.
// This type is often used to represent values that can be _null_.
type maybe <a> :: V -> V {
  con Nothing : forall<a> (maybe :: V -> V)<a>;
  con Just(value: a) : forall<a> (value : a) -> (maybe :: V -> V)<a>;
};
// Abstract type used for passing `null` values to external functions
type null <a> :: V -> V ;
// Optional is used internally by the compiler to pass optional arguments.
// It is usually displayed as `:?a` for some type `:a`.
type optional <a> :: V -> V {
  // The `Optional` constructor is used when an optional argument is given.
  con Optional(value: a) : forall<a> (value : a) -> ?a;
  // `None` is used when an optional argument is not provided.
  con None : forall<a> ?a;
};
// An enumeration to represent order
type order {
  con Lt : order;
  con Eq : order;
  con Gt : order;
};
// An alias for pure effects: a pure function always returns the same result
// when called with the same arguments but may not terminate or raise an exception.
alias pure :: E = <(exn :: X),(div :: X)> = 1;
// Resources identify specific handlers
type resource <(a :: HX)> :: HX -> V {
  con .Resource(int) : forall<(a :: HX)> (int) -> (resource :: HX -> V)<(a :: HX)>;
};
type resume-context <a,(e :: E),b> :: (V, E, V) -> V ;
type resume-context1 <a,(e :: E),b,c> :: (V, E, V, V) -> V ;
// A `:sslice` represents a sub-slice of string and
// has a specific start position and character count. It is used
// instead of string indices to make the actual internal representation
// of strings abstract (like UTF-8 or UTF-16). String slices are
// returned by functions that find sub strings or patterns in
// in strings. Use `string:(slice : sslice) -> string` to
// create a fresh substring from a slice.
type sslice {
  
};
// A `:stream` is a co-inductive type reprenting an infinite list of elements.
cotype rec stream <a> :: V -> V {
  con Next(head: a, tail: (stream :: V -> V)<a>) : forall<a> (head : a, tail : (stream :: V -> V)<a>) -> (stream :: V -> V)<a>;
};
// An alias for the empty effect.
alias total :: E = total = 1;
// The type of immutable arrays is called `:vector`.
type vector <a> :: V -> V ;
// The `:void` type is empty and has no constructors.
// See also the `:()` unit type and the `:bool` type.
type void ;
type extend exception-info {
  
};
// Raise a pattern match exception. This is function is used internally by the
// compiler to generate error messages on pattern match failures.
public fun error-pattern : forall<a> (location : string, definition : string) -> exn a
  = forall<a> fun<exn>(location:string, definition:string){
    std/core/(.extern-error-pattern){@}(location, definition)
  };
public fun (.copy) : (()) -> ()
  = fun(.this:()){
    std/core/()
  };
// Automatically generated. Retrieves the `fst` constructor field of the `:(,)` type.
public fun fst : forall<a,b> ((a, b)) -> a
  = forall<a,b> fun(.this:(a, b)){
    match (.this) {
      std/core/(,)(.x, _) -> .x
    }
  };
// Automatically generated. Retrieves the `snd` constructor field of the `:(,)` type.
public fun snd : forall<a,b> ((a, b)) -> b
  = forall<a,b> fun(.this:(a, b)){
    match (.this) {
      std/core/(,)(_, .x) -> .x
    }
  };
public fun (.copy) .1 : forall<a,b> ((a, b), fst : ?a, snd : ?b) -> (a, b)
  = forall<a,b> fun(.this:(a, b), fst0:?a, snd0:?b){
    val (.fst) .2484 : a
      = match (fst0) {
        std/core/Optional(.fst.2485) -> .fst.2485
        _ -> std/core/fst{2,1,fast}(.this)
      };;
    val (.snd) .2492 : b
      = match (snd0) {
        std/core/Optional(.snd.2493) -> .snd.2493
        _ -> std/core/snd{2,1,fast}(.this)
      };;
    std/core/(,)(.fst.2484, .snd.2492)
  };
// Automatically generated. Tests for the `Exn` constructor of the `:try` type.
public fun exn? : forall<a> (try : try<a>) -> bool
  = forall<a> fun(try0:try<a>){
    match (try0) {
      std/core/Exn(_) -> std/core/True
      _ -> std/core/False
    }
  };
// Automatically generated. Tests for the `Ok` constructor of the `:try` type.
public fun ok? : forall<a> (try : try<a>) -> bool
  = forall<a> fun(try0:try<a>){
    match (try0) {
      std/core/Ok(_) -> std/core/True
      _ -> std/core/False
    }
  };
// Automatically generated. Retrieves the `fst` constructor field of the `:(,,)` type.
public fun fst .1 : forall<a,b,c> ((a, b, c)) -> a
  = forall<a,b,c> fun(.this:(a, b, c)){
    match (.this) {
      std/core/(,,)(.x, _, _) -> .x
    }
  };
// Automatically generated. Retrieves the `snd` constructor field of the `:(,,)` type.
public fun snd .1 : forall<a,b,c> ((a, b, c)) -> b
  = forall<a,b,c> fun(.this:(a, b, c)){
    match (.this) {
      std/core/(,,)(_, .x, _) -> .x
    }
  };
// Automatically generated. Retrieves the `thd` constructor field of the `:(,,)` type.
public fun thd : forall<a,b,c> ((a, b, c)) -> c
  = forall<a,b,c> fun(.this:(a, b, c)){
    match (.this) {
      std/core/(,,)(_, _, .x) -> .x
    }
  };
public fun (.copy) .2 : forall<a,b,c> ((a, b, c), fst : ?a, snd : ?b, thd : ?c) -> (a, b, c)
  = forall<a,b,c> fun(.this:(a, b, c), fst0:?a, snd0:?b, thd0:?c){
    val (.fst) .2702 : a
      = match (fst0) {
        std/core/Optional(.fst.2703) -> .fst.2703
        _ -> std/core/fst.1{3,1,fast}(.this)
      };;
    val (.snd) .2743 : b
      = match (snd0) {
        std/core/Optional(.snd.2744) -> .snd.2744
        _ -> std/core/snd.1{3,1,fast}(.this)
      };;
    val (.thd) .2752 : c
      = match (thd0) {
        std/core/Optional(.thd.2753) -> .thd.2753
        _ -> std/core/thd{3,1,fast}(.this)
      };;
    std/core/(,,)(.fst.2702, .snd.2743, .thd.2752)
  };
// Automatically generated. Retrieves the `fst` constructor field of the `:(,,,)` type.
public fun fst .2 : forall<a,b,c,d> ((a, b, c, d)) -> a
  = forall<a,b,c,d> fun(.this:(a, b, c, d)){
    match (.this) {
      std/core/(,,,)(.x, _, _, _) -> .x
    }
  };
// Automatically generated. Retrieves the `snd` constructor field of the `:(,,,)` type.
public fun snd .2 : forall<a,b,c,d> ((a, b, c, d)) -> b
  = forall<a,b,c,d> fun(.this:(a, b, c, d)){
    match (.this) {
      std/core/(,,,)(_, .x, _, _) -> .x
    }
  };
// Automatically generated. Retrieves the `thd` constructor field of the `:(,,,)` type.
public fun thd .1 : forall<a,b,c,d> ((a, b, c, d)) -> c
  = forall<a,b,c,d> fun(.this:(a, b, c, d)){
    match (.this) {
      std/core/(,,,)(_, _, .x, _) -> .x
    }
  };
// Automatically generated. Retrieves the `field4` constructor field of the `:(,,,)` type.
public fun field4 : forall<a,b,c,d> ((a, b, c, d)) -> d
  = forall<a,b,c,d> fun(.this:(a, b, c, d)){
    match (.this) {
      std/core/(,,,)(_, _, _, .x) -> .x
    }
  };
public fun (.copy) .3 : forall<a,b,c,d> ((a, b, c, d), fst : ?a, snd : ?b, thd : ?c, field4 : ?d) -> (a, b, c, d)
  = forall<a,b,c,d> fun(.this:(a, b, c, d), fst0:?a, snd0:?b, thd0:?c, field40:?d){
    val (.fst) .3104 : a
      = match (fst0) {
        std/core/Optional(.fst.3105) -> .fst.3105
        _ -> std/core/fst.2{4,1,fast}(.this)
      };;
    val (.snd) .3168 : b
      = match (snd0) {
        std/core/Optional(.snd.3169) -> .snd.3169
        _ -> std/core/snd.2{4,1,fast}(.this)
      };;
    val (.thd) .3219 : c
      = match (thd0) {
        std/core/Optional(.thd.3220) -> .thd.3220
        _ -> std/core/thd.1{4,1,fast}(.this)
      };;
    val (.field4) .3229 : d
      = match (field40) {
        std/core/Optional(.field4.3230) -> .field4.3230
        _ -> std/core/field4{4,1,fast}(.this)
      };;
    std/core/(,,,)(.fst.3104, .snd.3168, .thd.3219, .field4.3229)
  };
// Automatically generated. Retrieves the `fst` constructor field of the `:(,,,,)` type.
public fun fst .3 : forall<a,b,c,d,a1> ((a, b, c, d, a1)) -> a
  = forall<a,b,c,d,a1> fun(.this:(a, b, c, d, a1)){
    match (.this) {
      std/core/(,,,,)(.x, _, _, _, _) -> .x
    }
  };
// Automatically generated. Retrieves the `snd` constructor field of the `:(,,,,)` type.
public fun snd .3 : forall<a,b,c,d,a1> ((a, b, c, d, a1)) -> b
  = forall<a,b,c,d,a1> fun(.this:(a, b, c, d, a1)){
    match (.this) {
      std/core/(,,,,)(_, .x, _, _, _) -> .x
    }
  };
// Automatically generated. Retrieves the `thd` constructor field of the `:(,,,,)` type.
public fun thd .2 : forall<a,b,c,d,a1> ((a, b, c, d, a1)) -> c
  = forall<a,b,c,d,a1> fun(.this:(a, b, c, d, a1)){
    match (.this) {
      std/core/(,,,,)(_, _, .x, _, _) -> .x
    }
  };
// Automatically generated. Retrieves the `field4` constructor field of the `:(,,,,)` type.
public fun field4 .1 : forall<a,b,c,d,a1> ((a, b, c, d, a1)) -> d
  = forall<a,b,c,d,a1> fun(.this:(a, b, c, d, a1)){
    match (.this) {
      std/core/(,,,,)(_, _, _, .x, _) -> .x
    }
  };
// Automatically generated. Retrieves the `field5` constructor field of the `:(,,,,)` type.
public fun field5 : forall<a,b,c,d,a1> ((a, b, c, d, a1)) -> a1
  = forall<a,b,c,d,a1> fun(.this:(a, b, c, d, a1)){
    match (.this) {
      std/core/(,,,,)(_, _, _, _, .x) -> .x
    }
  };
public fun (.copy) .4 : forall<a,b,c,d,a1> ((a, b, c, d, a1), fst : ?a, snd : ?b, thd : ?c, field4 : ?d, field5 : ?a1) -> (a, b, c, d, a1)
  = forall<a,b,c,d,a1> fun(.this:(a, b, c, d, a1), fst0:?a, snd0:?b, thd0:?c, field40:?d, field50:?a1){
    val (.fst) .3811 : a
      = match (fst0) {
        std/core/Optional(.fst.3812) -> .fst.3812
        _ -> std/core/fst.3{5,1,fast}(.this)
      };;
    val (.snd) .3903 : b
      = match (snd0) {
        std/core/Optional(.snd.3904) -> .snd.3904
        _ -> std/core/snd.3{5,1,fast}(.this)
      };;
    val (.thd) .3981 : c
      = match (thd0) {
        std/core/Optional(.thd.3982) -> .thd.3982
        _ -> std/core/thd.2{5,1,fast}(.this)
      };;
    val (.field4) .4042 : d
      = match (field40) {
        std/core/Optional(.field4.4043) -> .field4.4043
        _ -> std/core/field4.1{5,1,fast}(.this)
      };;
    val (.field5) .4053 : a1
      = match (field50) {
        std/core/Optional(.field5.4054) -> .field5.4054
        _ -> std/core/field5{5,1,fast}(.this)
      };;
    std/core/(,,,,)(.fst.3811, .snd.3903, .thd.3981, .field4.4042, .field5.4053)
  };
// Automatically generated. Tests for the `False` constructor of the `:bool` type.
public fun false? : (bool : bool) -> bool
  = fun(bool0:bool){
    match (bool0) {
      std/core/False() -> std/core/True
      _ -> std/core/False
    }
  };
// Automatically generated. Tests for the `True` constructor of the `:bool` type.
public fun true? : (bool : bool) -> bool
  = fun(bool0:bool){
    match (bool0) {
      std/core/True() -> std/core/True
      _ -> std/core/False
    }
  };
// Automatically generated. Tests for the `Left` constructor of the `:either` type.
public fun left? : forall<a,b> (either : either<a,b>) -> bool
  = forall<a,b> fun(either:either<a,b>){
    match (either) {
      std/core/Left(_) -> std/core/True
      _ -> std/core/False
    }
  };
// Automatically generated. Tests for the `Right` constructor of the `:either` type.
public fun right? : forall<a,b> (either : either<a,b>) -> bool
  = forall<a,b> fun(either:either<a,b>){
    match (either) {
      std/core/Right(_) -> std/core/True
      _ -> std/core/False
    }
  };
// Automatically generated. Retrieves the `dref` constructor field of the `:delayed` type.
fun dref : forall<e,a> (delayed : delayed<e,a>) -> ref<global,either<() -> e a,a>>
  = forall<e,a> fun(delayed:delayed<e,a>){
    match (delayed) {
      std/core/Delay(.x) -> .x
    }
  };
fun (.copy) .5 : forall<e,a> (delayed<e,a>, dref : ?ref<global,either<() -> e a,a>>) -> delayed<e,a>
  = forall<e,a> fun(.this:delayed<e,a>, dref0:?ref<global,either<() -> e a,a>>){
    std/core/bind{@}(match (dref0) {
        std/core/Optional(.dref.4240) -> .dref.4240
        _ -> std/core/dref{2,1,fast}(.this)
      }, (fun(.c.0:ref<global,either<() -> e a,a>>){
        (std/core/Delay(.c.0))
      }))
  };
// Automatically generated. Tests for the `Error` constructor of the `:exception-info` type.
public fun error? : (exception-info : exception-info) -> bool
  = fun(exception-info:exception-info){
    match (exception-info) {
      std/core/Error() -> std/core/True
      _ -> std/core/False
    }
  };
// Automatically generated. Tests for the `Assert` constructor of the `:exception-info` type.
public fun assert? : (exception-info : exception-info) -> bool
  = fun(exception-info:exception-info){
    match (exception-info) {
      std/core/Assert() -> std/core/True
      _ -> std/core/False
    }
  };
// Automatically generated. Tests for the `Todo` constructor of the `:exception-info` type.
public fun todo? : (exception-info : exception-info) -> bool
  = fun(exception-info:exception-info){
    match (exception-info) {
      std/core/Todo() -> std/core/True
      _ -> std/core/False
    }
  };
// Automatically generated. Tests for the `Range` constructor of the `:exception-info` type.
public fun range? : (exception-info : exception-info) -> bool
  = fun(exception-info:exception-info){
    match (exception-info) {
      std/core/Range() -> std/core/True
      _ -> std/core/False
    }
  };
// Automatically generated. Tests for the `Finalize` constructor of the `:exception-info` type.
public fun finalize? : (exception-info : exception-info) -> bool
  = fun(exception-info:exception-info){
    match (exception-info) {
      std/core/Finalize() -> std/core/True
      _ -> std/core/False
    }
  };
// Automatically generated. Tests for the `Pattern` constructor of the `:exception-info` type.
public fun pattern? : (exception-info : exception-info) -> bool
  = fun(exception-info:exception-info){
    match (exception-info) {
      std/core/Pattern(_, _) -> std/core/True
      _ -> std/core/False
    }
  };
// Automatically generated. Tests for the `System` constructor of the `:exception-info` type.
public fun system? : (exception-info : exception-info) -> bool
  = fun(exception-info:exception-info){
    match (exception-info) {
      std/core/System(_) -> std/core/True
      _ -> std/core/False
    }
  };
// Automatically generated. Tests for the `Internal` constructor of the `:exception-info` type.
public fun internal? : (exception-info : exception-info) -> bool
  = fun(exception-info:exception-info){
    match (exception-info) {
      std/core/Internal(_) -> std/core/True
      _ -> std/core/False
    }
  };
public val (.tag-Error) : string
  = "std/core/Error";
public val (.tag-Assert) : string
  = "std/core/Assert";
public val (.tag-Todo) : string
  = "std/core/Todo";
public val (.tag-Range) : string
  = "std/core/Range";
public val (.tag-Finalize) : string
  = "std/core/Finalize";
public val (.tag-Pattern) : string
  = "std/core/Pattern";
public val (.tag-System) : string
  = "std/core/System";
public val (.tag-Internal) : string
  = "std/core/Internal";
// Automatically generated. Tests for the `Nil` constructor of the `:list` type.
public fun nil? : forall<a> (list : list<a>) -> bool
  = forall<a> fun(list0:list<a>){
    match (list0) {
      std/core/Nil() -> std/core/True
      _ -> std/core/False
    }
  };
// Automatically generated. Tests for the `Cons` constructor of the `:list` type.
public fun cons? : forall<a> (list : list<a>) -> bool
  = forall<a> fun(list0:list<a>){
    match (list0) {
      std/core/Cons(_, _) -> std/core/True
      _ -> std/core/False
    }
  };
// Automatically generated. Tests for the `Nothing` constructor of the `:maybe` type.
public fun nothing? : forall<a> (maybe : maybe<a>) -> bool
  = forall<a> fun(maybe0:maybe<a>){
    match (maybe0) {
      std/core/Nothing() -> std/core/True
      _ -> std/core/False
    }
  };
// Automatically generated. Tests for the `Just` constructor of the `:maybe` type.
public fun just? : forall<a> (maybe : maybe<a>) -> bool
  = forall<a> fun(maybe0:maybe<a>){
    match (maybe0) {
      std/core/Just(_) -> std/core/True
      _ -> std/core/False
    }
  };
// Automatically generated. Tests for the `Optional` constructor of the `:optional` type.
public fun optional? : forall<a> (optional : ?a) -> bool
  = forall<a> fun(optional:?a){
    match (optional) {
      std/core/Optional(_) -> std/core/True
      _ -> std/core/False
    }
  };
// Automatically generated. Tests for the `None` constructor of the `:optional` type.
public fun none? : forall<a> (optional : ?a) -> bool
  = forall<a> fun(optional:?a){
    match (optional) {
      std/core/None() -> std/core/True
      _ -> std/core/False
    }
  };
// Automatically generated. Tests for the `Lt` constructor of the `:order` type.
public fun lt? : (order : order) -> bool
  = fun(order0:order){
    match (order0) {
      std/core/Lt() -> std/core/True
      _ -> std/core/False
    }
  };
// Automatically generated. Tests for the `Eq` constructor of the `:order` type.
public fun eq? : (order : order) -> bool
  = fun(order0:order){
    match (order0) {
      std/core/Eq() -> std/core/True
      _ -> std/core/False
    }
  };
// Automatically generated. Tests for the `Gt` constructor of the `:order` type.
public fun gt? : (order : order) -> bool
  = fun(order0:order){
    match (order0) {
      std/core/Gt() -> std/core/True
      _ -> std/core/False
    }
  };
// Automatically generated. Retrieves the `str` constructor field of the `:sslice` type.
fun str : (sslice : sslice) -> string
  = fun(sslice:sslice){
    match (sslice) {
      std/core/Sslice(.x, _, _) -> .x
    }
  };
// Automatically generated. Retrieves the `start` constructor field of the `:sslice` type.
fun start : (sslice : sslice) -> int32
  = fun(sslice:sslice){
    match (sslice) {
      std/core/Sslice(_, .x, _) -> .x
    }
  };
// Automatically generated. Retrieves the `len` constructor field of the `:sslice` type.
fun len : (sslice : sslice) -> int32
  = fun(sslice:sslice){
    match (sslice) {
      std/core/Sslice(_, _, .x) -> .x
    }
  };
fun (.copy) .6 : (sslice, str : ?string, start : ?int32, len : ?int32) -> sslice
  = fun(.this:sslice, str0:?string, start0:?int32, len0:?int32){
    val (.str) .4523 : string
      = match (str0) {
        std/core/Optional(.str.4524) -> .str.4524
        _ -> std/core/str{0,1,fast}(.this)
      };;
    val (.start) .4529 : int32
      = match (start0) {
        std/core/Optional(.start.4530) -> .start.4530
        _ -> std/core/start{0,1,fast}(.this)
      };;
    val (.len) .4535 : int32
      = match (len0) {
        std/core/Optional(.len.4536) -> .len.4536
        _ -> std/core/len{0,1,fast}(.this)
      };;
    std/core/Sslice(.str.4523, .start.4529, .len.4535)
  };
// Automatically generated. Retrieves the `head` constructor field of the `:stream` type.
public fun head : forall<a> (stream : stream<a>) -> a
  = forall<a> fun(stream:stream<a>){
    match (stream) {
      std/core/Next(.x, _) -> .x
    }
  };
// Automatically generated. Retrieves the `tail` constructor field of the `:stream` type.
public fun tail : forall<a> (stream : stream<a>) -> stream<a>
  = forall<a> fun(stream:stream<a>){
    match (stream) {
      std/core/Next(_, .x) -> .x
    }
  };
public fun (.copy) .7 : forall<a> (stream<a>, head : ?a, tail : ?stream<a>) -> stream<a>
  = forall<a> fun(.this:stream<a>, head0:?a, tail0:?stream<a>){
    val (.head) .4628 : a
      = match (head0) {
        std/core/Optional(.head.4629) -> .head.4629
        _ -> std/core/head{1,1,fast}(.this)
      };;
    val (.tail) .4635 : stream<a>
      = match (tail0) {
        std/core/Optional(.tail.4636) -> .tail.4636
        _ -> std/core/tail{1,1,fast}(.this)
      };;
    std/core/Next(.head.4628, .tail.4635)
  };
// Automatically generated. Tests for the `Cancel` constructor of the `:exception-info` type.
fun cancel? : (exception-info : exception-info) -> bool
  = fun(exception-info:exception-info){
    match (exception-info) {
      std/core/Cancel() -> std/core/True
      _ -> std/core/False
    }
  };
val (.tag-Cancel) : string
  = "std/core/Cancel";
public fun (.makeFreshResourceHandler0) : forall<a,b,c,e,e1> (effect-name : string, reinit : null<() -> e ()>, ret : null<(a) -> e b>, final : null<() -> e ()>, branches : vector<handler-branch0<e,b>>, handler-kind : int, resource-tag : int, resource-wrap : (int) -> c) -> total ((action : (c) -> e1 a) -> e b)
  = forall<a,b,c,e,e1> fun(effect-name:string, reinit:null<() -> e ()>, ret:null<(a) -> e b>, final:null<() -> e ()>, branches:vector<handler-branch0<e,b>>, handler-kind:int, resource-tag:int, resource-wrap:(int) -> c){
    std/core/(.extern-makeFreshResourceHandler0){@}(effect-name, reinit, ret, final, branches, handler-kind, resource-tag, resource-wrap)
  };
public fun (.makeFreshResourceHandler1) : forall<a,b,c,e,d,e1> (effect-name : string, reinit : null<(local : d) -> e d>, ret : null<(result : a, local : d) -> e b>, final : null<(local : d) -> e ()>, branches : vector<handler-branch1<e,d,b>>, handler-kind : int, resource-tag : int, resource-wrap : (int) -> c) -> total ((initial-local : d, action : (c) -> e1 a) -> e b)
  = forall<a,b,c,e,d,e1> fun(effect-name:string, reinit:null<(local : d) -> e d>, ret:null<(result : a, local : d) -> e b>, final:null<(local : d) -> e ()>, branches:vector<handler-branch1<e,d,b>>, handler-kind:int, resource-tag:int, resource-wrap:(int) -> c){
    std/core/(.extern-makeFreshResourceHandler1){@}(effect-name, reinit, ret, final, branches, handler-kind, resource-tag, resource-wrap)
  };
public fun (.makeHandler0) : forall<a,b,e,e1> (effect-name : string, reinit : null<() -> e ()>, ret : null<(a) -> e b>, final : null<() -> e ()>, branches : vector<handler-branch0<e,b>>, handler-kind : int) -> total ((action : () -> e1 a) -> e b)
  = forall<a,b,e,e1> fun(effect-name:string, reinit:null<() -> e ()>, ret:null<(a) -> e b>, final:null<() -> e ()>, branches:vector<handler-branch0<e,b>>, handler-kind:int){
    std/core/(.extern-makeHandler0){@}(effect-name, reinit, ret, final, branches, handler-kind)
  };
public fun (.makeHandler1) : forall<a,b,e,c,e1> (effect-name : string, reinit : null<(local : c) -> e c>, ret : null<(result : a, local : c) -> e b>, final : null<(local : c) -> e ()>, branches : vector<handler-branch1<e,c,b>>, handler-kind : int) -> total ((initial-local : c, action : () -> e1 a) -> e b)
  = forall<a,b,e,c,e1> fun(effect-name:string, reinit:null<(local : c) -> e c>, ret:null<(result : a, local : c) -> e b>, final:null<(local : c) -> e ()>, branches:vector<handler-branch1<e,c,b>>, handler-kind:int){
    std/core/(.extern-makeHandler1){@}(effect-name, reinit, ret, final, branches, handler-kind)
  };
public fun (.makeHandlerBranch0) : forall<a,b,c,e> (resume-kind : int, op-name : string, branch : (resume-context<a,e,b>, op : c) -> e b) -> total handler-branch0<e,b>
  = forall<a,b,c,e> fun(resume-kind:int, op-name:string, branch:(resume-context<a,e,b>, op : c) -> e b){
    std/core/(.extern-makeHandlerBranch0){@}(resume-kind, op-name, branch)
  };
public fun (.makeHandlerBranch0-x1) : forall<a,e> (resume-kind : int, op-name : string, branch : any) -> total handler-branch0<e,a>
  = forall<a,e> fun(resume-kind:int, op-name:string, branch:any){
    std/core/(.extern-makeHandlerBranch0-x1){@}(resume-kind, op-name, branch)
  };
public fun (.makeHandlerBranch1) : forall<a,b,c,e,d> (resume-kind : int, op-name : string, branch : (resume-context1<a,e,b,d>, op : c, local : d) -> e b) -> total handler-branch1<e,d,b>
  = forall<a,b,c,e,d> fun(resume-kind:int, op-name:string, branch:(resume-context1<a,e,b,d>, op : c, local : d) -> e b){
    std/core/(.extern-makeHandlerBranch1){@}(resume-kind, op-name, branch)
  };
public fun (.makeHandlerBranch1-x1) : forall<a,e,b> (resume-kind : int, op-name : string, branch : any) -> total handler-branch1<e,b,a>
  = forall<a,e,b> fun(resume-kind:int, op-name:string, branch:any){
    std/core/(.extern-makeHandlerBranch1-x1){@}(resume-kind, op-name, branch)
  };
// Used for handlers with just a `return` branch
public fun (.makeHandlerRet0) : forall<a,b,e> (ignored-effect-name : string, reinit : null<() -> e ()>, ret : null<(result : a) -> e b>, final : null<() -> e ()>, ignored-branches : int, ignored-kind : int) -> total ((action : () -> e a) -> e b)
  = forall<a,b,e> fun(ignored-effect-name:string, reinit:null<() -> e ()>, ret:null<(result : a) -> e b>, final:null<() -> e ()>, ignored-branches:int, ignored-kind:int){
    std/core/(.extern-makeHandlerRet0){@}(ignored-effect-name, reinit, ret, final, ignored-branches, ignored-kind)
  };
// Used for handlers with just a `return` branch
public fun (.makeHandlerRet1) : forall<a,b,e,c> (ignored-effect-name : string, reinit : null<(local : c) -> e c>, ret : null<(result : a, local : c) -> e b>, final : null<(local : c) -> e ()>, ignored-branches : int, ignored-kind : int) -> total ((local : c, action : () -> e a) -> e b)
  = forall<a,b,e,c> fun(ignored-effect-name:string, reinit:null<(local : c) -> e c>, ret:null<(result : a, local : c) -> e b>, final:null<(local : c) -> e ()>, ignored-branches:int, ignored-kind:int){
    std/core/(.extern-makeHandlerRet1){@}(ignored-effect-name, reinit, ret, final, ignored-branches, ignored-kind)
  };
public fun (.makeResourceHandler0) : forall<a,b,e,e1> (effect-name : string, reinit : null<() -> e ()>, ret : null<(a) -> e b>, final : null<() -> e ()>, branches : vector<handler-branch0<e,b>>, handler-kind : int, resource-tag : int) -> total ((action : () -> e1 a) -> e b)
  = forall<a,b,e,e1> fun(effect-name:string, reinit:null<() -> e ()>, ret:null<(a) -> e b>, final:null<() -> e ()>, branches:vector<handler-branch0<e,b>>, handler-kind:int, resource-tag:int){
    std/core/(.extern-makeResourceHandler0){@}(effect-name, reinit, ret, final, branches, handler-kind, resource-tag)
  };
public fun (.makeResourceHandler1) : forall<a,b,e,c,e1> (effect-name : string, reinit : null<(local : c) -> e c>, ret : null<(result : a, local : c) -> e b>, final : null<(local : c) -> e ()>, branches : vector<handler-branch1<e,c,b>>, handler-kind : int, resource-tag : int) -> total ((initial-local : c, action : () -> e1 a) -> e b)
  = forall<a,b,e,c,e1> fun(effect-name:string, reinit:null<(local : c) -> e c>, ret:null<(result : a, local : c) -> e b>, final:null<(local : c) -> e ()>, branches:vector<handler-branch1<e,c,b>>, handler-kind:int, resource-tag:int){
    std/core/(.extern-makeResourceHandler1){@}(effect-name, reinit, ret, final, branches, handler-kind, resource-tag)
  };
// Internal export for the regex module
public fun (.new-sslice) : (str : string, start : int32, len : int32) -> sslice
  = fun(str0:string, start0:int32, len0:int32){
    std/core/Sslice(str0, start0, len0)
  };
// Unsafe: transform any type to a `null` type; used internally by the compiler.
public fun (.null-any) : forall<a> (x : a) -> null<a>
  = forall<a> fun(x:a){
    std/core/(.extern-null-any){@}(x)
  };
public fun (.yieldop) : forall<a,b> (effect-name : string, op-name : string, op-resource : int, op-idx : int, op : a) -> yld<b>
  = forall<a,b> fun(effect-name:string, op-name:string, op-resource:int, op-idx:int, op:a){
    std/core/(.extern-yieldop){@}(effect-name, op-name, op-resource, op-idx, op)
  };
public fun (.yieldop-x1) : forall<a,b,c> (effect-name : string, op-name : string, op-resource : int, op-idx : int, op : a, def : maybe<c>) -> yld<b>
  = forall<a,b,c> fun(effect-name:string, op-name:string, op-resource:int, op-idx:int, op:a, def:maybe<c>){
    std/core/(.extern-yieldop-x1){@}(effect-name, op-name, op-resource, op-idx, op, def)
  };
fun string-compare : (x : string, y : string) -> int
  = fun(x:string, y:string){
    std/core/(.extern-string-compare){@}(x, y)
  };
val maxListStack : int
  = 100;
// Efficiently reverse a list `xs` and append it to `tl`:\
// `reverse-append(xs,tl) == reserve(xs) + tl
public fun reverse-append : forall<a> (xs : list<a>, tl : list<a>) -> list<a>
  = forall<a> fun(xs:list<a>, tl:list<a>){
    fun** reverse-acc : forall<b> (acc : list<b>, ys : list<b>) -> list<b>
      = forall<b> fun(acc:list<b>, ys:list<b>){
        match (ys) {
          std/core/Cons(x, xx) -> reverse-acc{1,2,fast}((std/core/Cons(x, acc)), xx)
          _ -> acc
        }
      };;
    reverse-acc{1,2,fast}(tl, xs)
  };
// Raise an integer `i` to the power of `exp`.
public fun pow : (i : int, exp : int) -> int
  = fun(i:int, exp:int){
    std/core/(.extern-pow){@}(i, exp)
  };
// Compose two funs `f` and `g`.
public fun o : forall<a,b,c,e> (f : (a) -> e b, g : (c) -> e a) -> ((x : c) -> e b)
  = forall<a,b,c,e> fun(f:(a) -> e b, g:(c) -> e a){
    fun<e>(x:c){
      std/core/bind{@}((g(x)), f)
    }
  };
// The identity function returns its argument unchanged.
public fun id : forall<a> (x : a) -> a
  = forall<a> fun(x:a){
    x
  };
// Convert a vector to a list with an optional tail.
public fun vlist : forall<a> (v : vector<a>, tail : ?list<a>) -> list<a>
  = forall<a> fun(v:vector<a>, tail0:?list<a>){
    val .tail.5246 : list<a>
          = match (tail0) {
            std/core/Optional(.tail.5247) -> .tail.5247
            _ -> std/core/Nil
          };
    std/core/(.extern-vlist){@}(v, .tail.5246)
  };
// Convert a character to a string
public fun string : (c : char) -> string
  = fun(c:char){
    std/core/(.extern-string){@}(c)
  };
// Convert a vector of characters to a string.
public fun string .1 : (vector<char>) -> string
  = fun(.arg1:vector<char>){
    std/core/(.extern-string.1){@}(.arg1)
  };
// Convert a list of characters to a string
public fun string .2 : (cs : list<char>) -> total string
  = fun<total>(cs:list<char>){
    std/core/(.extern-string.2){@}(cs)
  };
// O(n). Copy the `slice` argument into a fresh string.
// Takes O(1) time if the slice covers the entire string.
public fun string .3 : (slice : sslice) -> string
  = fun(slice0:sslice){
    std/core/(.extern-string.3){@}(slice0)
  };
// Convert a `:maybe` string to a string using the empty sting for `Nothing`
public fun string .4 : (ms : maybe<string>) -> string
  = fun(ms:maybe<string>){
    match (ms) {
      std/core/Nothing() -> ""
      std/core/Just(s) -> s
    }
  };
// O(`count`). Advance the start position of a string slice by `count` characters
// up to the end of the string.
// A negative `count` advances the start position backwards upto the first position
// in a string.
// Maintains the character count of the original slice upto the end of the string.
// For example:
//
// * `"abc".first.advance(1).string == "b"`,
// * `"abc".first.advance(3).string == ""`,
// * `"abc".last.advance(-1).string == "b"`.
//
public fun advance : (slice : sslice, count : int) -> sslice
  = fun(slice0:sslice, count:int){
    std/core/(.extern-advance){@}(slice0, count)
  };
// Apply a function `f` to a specified argument `x`.
public fun* (.bind-apply) : forall<a,b,e> (f : (a) -> e b, x : a) -> e b
  = forall<a,b,e> fun<e>(f:(a) -> e b, x:a){
    f(x)
  };
// Apply a function `f` to a specified argument `x`.
public fun (.fast-apply) : forall<a,b,e> (f : (a) -> e b, x : a) -> e b
  = forall<a,b,e> fun<e>(f:(a) -> e b, x:a){
    f(x)
  };
// Apply a function `f` to a specified argument `x`.
public fun** apply : forall<a,b,e> (f : (a) -> e b, x : a) -> e b
  = forall<a,b,e> fun<e>(f:(a) -> e b, x:a){
    std/core/(.bind-apply){3,2,bind}(f, x)
  };
public fun exception : (message : string, info : exception-info) -> exception
  = fun(message0:string, info0:exception-info){
    std/core/(.extern-exception){@}(message0, info0)
  };
// _Unsafe_. This function calls a function and pretends it did not have any effect at all.
public fun unsafe-total : forall<a,e> (action : () -> e a) -> total a
  = forall<a,e> fun(action:() -> e a){
    std/core/unsafe-total-cast{@}(action)()
  };
// O(1). Return the string slice from the start of a string up to the
// start of `slice` argument.
public fun before : (slice : sslice) -> sslice
  = fun(slice0:sslice){
    match (slice0) {
      std/core/Sslice(s, start0, _) -> std/core/Sslice(s, (std/core/int32{@}(0)), start0)
    }
  };
public fun info : (exn : exception) -> exception-info
  = fun(exn:exception){
    std/core/(.extern-info){@}(exn)
  };
// O(`count`). Extend a string slice by `count` characters up to the end of the string.
// A negative `count` shrinks the slice up to the empty slice.
// For example:
//
// * `"abc".first.extend(1).string == "ab"`
// * `"abc".last.extend(-1).string == ""`
//
public fun extend : (slice : sslice, count : int) -> sslice
  = fun(slice0:sslice, count:int){
    std/core/(.extern-extend){@}(slice0, count)
  };
// Convert a string to upper-case
public fun to-upper : (s : string) -> string
  = fun(s:string){
    std/core/(.extern-to-upper){@}(s)
  };
public fun cdiv-exp10 : (i : int, n : int) -> int
  = fun(i:int, n:int){
    std/core/(.extern-cdiv-exp10){@}(i, n)
  };
public fun mul-exp10 : (i : int, n : int) -> int
  = fun(i:int, n:int){
    std/core/(.extern-mul-exp10){@}(i, n)
  };
// Return a random number equal or larger than 0.0 and smaller than 1.0
public fun random : () -> ndet double
  = fun<ndet>(){
    std/core/(.extern-random){@}()
  };
// Return the common prefix of two strings (upto `upto` characters (default is minimum length of the two strings))
public fun common-prefix : (s : string, t : string, upto : ?int) -> sslice
  = fun(s:string, t:string, upto:?int){
    val .upto.5466 : int
          = match (upto) {
            std/core/Optional(.upto.5467) -> .upto.5467
            _ -> -1
          };
    std/core/(.extern-common-prefix){@}(s, t, .upto.5466)
  };
// The `const` funs returns its first argument and ignores the second.
public fun const : forall<a,b> (x : a, y : b) -> a
  = forall<a,b> fun(x:a, y:b){
    x
  };
// Return a 'constant' function that ignores its argument and always returns the same result
public fun const .1 : forall<a,b> (default : a) -> total ((x : b) -> a)
  = forall<a,b> fun(default0:a){
    fun(_(439, 8):b){
      default0
    }
  };
// If the slice is not empty,
// return the first character, and a new slice that is advanced by 1.
public fun next : (slice : sslice) -> maybe<(char, sslice)>
  = fun(slice0:sslice){
    std/core/(.extern-next){@}(slice0)
  };
// Return the number of decimal digits of `i`. Return `0` when `i==0`.
public fun count-digits : (i : int) -> int
  = fun(i:int){
    std/core/(.extern-count-digits){@}(i)
  };
// Convert a `:maybe<a>` value to `:a`, using the `nothing` parameter for `Nothing`.
public fun default : forall<a> (m : maybe<a>, nothing : a) -> a
  = forall<a> fun(m:maybe<a>, nothing:a){
    match (m) {
      std/core/Nothing() -> nothing
      std/core/Just(x) -> x
    }
  };
// An empty slice
public val empty : sslice
  = std/core/Sslice("", (std/core/int32{@}(0)), (std/core/int32{@}(0)));
fun xends-with : (s : string, post : string) -> bool
  = fun(s:string, post:string){
    std/core/(.extern-xends-with){@}(s, post)
  };
// Is this an even integer?
public fun even? : (i : int) -> bool
  = fun(i:int){
    std/core/(!){@}((std/core/odd?{@}(i)))
  };
// Return the number of ending `0` digits of `i`. Return `0` when `i==0`.
public fun exp10? : (i : int) -> int
  = fun(i:int){
    std/core/(.extern-exp10?){@}(i)
  };
public fun* (.bind-finalize) : forall<a,b,c,e> (context : resume-context<a,e,b>, result : c) -> e c
  = forall<a,b,c,e> fun<e>(context:resume-context<a,e,b>, result:c){
    std/core/(.extern-finalize){@}(context, result)
  };
public fun (.fast-finalize) : forall<a,b,c,e> (context : resume-context<a,e,b>, result : c) -> e c
  = forall<a,b,c,e> fun<e>(context:resume-context<a,e,b>, result:c){
    std/core/(.extern-finalize){@}(context, result)
  };
public fun** finalize : forall<a,b,c,e> (context : resume-context<a,e,b>, result : c) -> e c
  = forall<a,b,c,e> fun<e>(context:resume-context<a,e,b>, result:c){
    std/core/(.bind-finalize){4,2,bind}(context, result)
  };
public fun* (.bind-finalize) .1 : forall<a,b,c,e,d> (context : resume-context1<a,e,b,d>, result : c) -> e c
  = forall<a,b,c,e,d> fun<e>(context:resume-context1<a,e,b,d>, result:c){
    std/core/(.extern-finalize.1){@}(context, result)
  };
public fun (.fast-finalize) .1 : forall<a,b,c,e,d> (context : resume-context1<a,e,b,d>, result : c) -> e c
  = forall<a,b,c,e,d> fun<e>(context:resume-context1<a,e,b,d>, result:c){
    std/core/(.extern-finalize.1){@}(context, result)
  };
public fun** finalize .1 : forall<a,b,c,e,d> (context : resume-context1<a,e,b,d>, result : c) -> e c
  = forall<a,b,c,e,d> fun<e>(context:resume-context1<a,e,b,d>, result:c){
    std/core/(.bind-finalize.1){5,2,bind}(context, result)
  };
// Execute a `hndler` no matter what exception was raised in `action`.
public fun* (.bind-finally) : forall<e,a> (action : () -> e a, hndl : () -> e ()) -> e a
  = forall<e,a> fun<e>(action:() -> e a, hndl:() -> e ()){
    std/core/(.extern-finally){@}(action, hndl)
  };
// Execute a `hndler` no matter what exception was raised in `action`.
public fun (.fast-finally) : forall<e,a> (action : () -> e a, hndl : () -> e ()) -> e a
  = forall<e,a> fun<e>(action:() -> e a, hndl:() -> e ()){
    std/core/(.extern-finally){@}(action, hndl)
  };
// Execute a `hndler` no matter what exception was raised in `action`.
public fun** finally : forall<e,a> (action : () -> e a, hndl : () -> e ()) -> e a
  = forall<e,a> fun<e>(action:() -> e a, hndl:() -> e ()){
    std/core/(.bind-finally){2,2,bind}(action, hndl)
  };
// Generic show: shows the internal representation of an object as a string
// Note: this breaks parametricity so it should not be public
fun gshow : forall<a> (a) -> string
  = forall<a> fun(.arg1:a){
    std/core/(.extern-gshow){@}(.arg1)
  };
// Print a string to the console
fun xprints : (string) -> console ()
  = fun<console>(.arg1:string){
    std/core/(.extern-xprints){@}(.arg1)
  };
fun int-show-hex : (i : int, use-capitals : bool) -> string
  = fun(i:int, use-capitals:bool){
    std/core/(.extern-int-show-hex){@}(i, use-capitals)
  };
fun repeat32 : (s : string, n : int32) -> string
  = fun(s:string, n:int32){
    std/core/(.extern-repeat32){@}(s, n)
  };
fun show-expx : (d : double, prec : int32) -> string
  = fun(d:double, prec:int32){
    std/core/(.extern-show-expx){@}(d, prec)
  };
fun show-fixedx : (d : double, prec : int32) -> string
  = fun(d:double, prec:int32){
    std/core/(.extern-show-fixedx){@}(d, prec)
  };
public fun stack-trace : (exn : exception) -> string
  = fun(exn:exception){
    std/core/(.extern-stack-trace){@}(exn)
  };
// Print a string to the console, including a final newline character.
fun xprintsln : (string) -> console ()
  = fun<console>(.arg1:string){
    std/core/(.extern-xprintsln){@}(.arg1)
  };
// Return the host environment: `dotnet`, `browser`, `webworker`, or `node`.
public fun host : () -> ndet string
  = fun<ndet>(){
    std/core/(.extern-host){@}()
  };
// The `ignore` function ignores its argument.
public fun ignore : forall<a> (x : a) -> ()
  = forall<a> fun(x:a){
    std/core/()
  };
public fun* (.bind-inject-exn) : forall<a,e> (action : () -> e a) -> <exn|e> a
  = forall<a,e> fun<<exn|e>>(action:() -> e a){
    std/core/(.extern-inject-exn){@}(action)
  };
public fun (.fast-inject-exn) : forall<a,e> (action : () -> e a) -> <exn|e> a
  = forall<a,e> fun<<exn|e>>(action:() -> e a){
    std/core/(.extern-inject-exn){@}(action)
  };
public fun** inject-exn : forall<a,e> (action : () -> e a) -> <exn|e> a
  = forall<a,e> fun<<exn|e>>(action:() -> e a){
    std/core/(.bind-inject-exn){2,1,bind}(action)
  };
// Insert a separator `sep`  between all elements of a list `xs` .
public fun intersperse : forall<a> (xs : list<a>, sep : a) -> list<a>
  = forall<a> fun(xs:list<a>, sep:a){
    //TODO: make tail recursive
    val before0 : forall<b> (list<b>, b) -> list<b>
      = forall<b> fun(ys:list<b>, s:b){
        match (ys) {
          std/core/Cons(y, yy) -> std/core/Cons(s, (std/core/Cons(y, (before0(yy, s)))))
          std/core/Nil() -> std/core/Nil
        }
      };;
    match (xs) {
      std/core/Cons(x, xx) -> std/core/Cons(x, (before0(xx, sep)))
      std/core/Nil() -> std/core/Nil
    }
  };
// Used by the compiler to wrap main console applications
public fun* (.bind-main-console) : forall<a,e> (main : () -> e a) -> e a
  = forall<a,e> fun<e>(main:() -> e a){
    std/core/(.extern-main-console){@}(main)
  };
// Used by the compiler to wrap main console applications
public fun (.fast-main-console) : forall<a,e> (main : () -> e a) -> e a
  = forall<a,e> fun<e>(main:() -> e a){
    std/core/(.extern-main-console){@}(main)
  };
// Used by the compiler to wrap main console applications
public fun** main-console : forall<a,e> (main : () -> e a) -> e a
  = forall<a,e> fun<e>(main:() -> e a){
    std/core/(.bind-main-console){2,1,bind}(main)
  };
public fun mbint : (m : maybe<int>) -> int
  = fun(m:maybe<int>){
    match (m) {
      std/core/Nothing() -> 0
      std/core/Just(i) -> i
    }
  };
// Return the message associated with an exception
public fun message : (exn : exception) -> string
  = fun(exn:exception){
    std/core/(.extern-message){@}(exn)
  };
public fun negate : (i : int) -> int
  = fun(i:int){
    std/core/(~){@}(i)
  };
fun* (.bind-prim-try-some) : forall<a,e> (action : () -> <exn|e> a, hndl : (exception) -> <exn|e> a) -> <exn|e> a
  = forall<a,e> fun<<exn|e>>(action:() -> <exn|e> a, hndl:(exception) -> <exn|e> a){
    std/core/(.extern-prim-try-some){@}(action, hndl)
  };
fun (.fast-prim-try-some) : forall<a,e> (action : () -> <exn|e> a, hndl : (exception) -> <exn|e> a) -> <exn|e> a
  = forall<a,e> fun<<exn|e>>(action:() -> <exn|e> a, hndl:(exception) -> <exn|e> a){
    std/core/(.extern-prim-try-some){@}(action, hndl)
  };
fun** prim-try-some : forall<a,e> (action : () -> <exn|e> a, hndl : (exception) -> <exn|e> a) -> <exn|e> a
  = forall<a,e> fun<<exn|e>>(action:() -> <exn|e> a, hndl:(exception) -> <exn|e> a){
    std/core/(.bind-prim-try-some){2,2,bind}(action, hndl)
  };
fun xparse-int : (s : string, hex : bool) -> maybe<int>
  = fun(s:string, hex:bool){
    std/core/(.extern-xparse-int){@}(s, hex)
  };
fun* (.bind-prim-try-all) : forall<a,e> (action : () -> <exn|e> a, hndl : (exception) -> e a) -> e a
  = forall<a,e> fun<e>(action:() -> <exn|e> a, hndl:(exception) -> e a){
    std/core/(.extern-prim-try-all){@}(action, hndl)
  };
fun (.fast-prim-try-all) : forall<a,e> (action : () -> <exn|e> a, hndl : (exception) -> e a) -> e a
  = forall<a,e> fun<e>(action:() -> <exn|e> a, hndl:(exception) -> e a){
    std/core/(.extern-prim-try-all){@}(action, hndl)
  };
fun** prim-try-all : forall<a,e> (action : () -> <exn|e> a, hndl : (exception) -> e a) -> e a
  = forall<a,e> fun<e>(action:() -> <exn|e> a, hndl:(exception) -> e a){
    std/core/(.bind-prim-try-all){2,2,bind}(action, hndl)
  };
// Return a positive random integer (including 0)
public fun random-int : () -> ndet int
  = fun<ndet>(){
    std/core/(.extern-random-int){@}()
  };
public fun* (.bind-resume) : forall<a,b,e> (context : resume-context<a,e,b>, result : a) -> e b
  = forall<a,b,e> fun<e>(context:resume-context<a,e,b>, result:a){
    std/core/(.extern-resume){@}(context, result)
  };
public fun (.fast-resume) : forall<a,b,e> (context : resume-context<a,e,b>, result : a) -> e b
  = forall<a,b,e> fun<e>(context:resume-context<a,e,b>, result:a){
    std/core/(.extern-resume){@}(context, result)
  };
public fun** resume : forall<a,b,e> (context : resume-context<a,e,b>, result : a) -> e b
  = forall<a,b,e> fun<e>(context:resume-context<a,e,b>, result:a){
    std/core/(.bind-resume){3,2,bind}(context, result)
  };
public fun* (.bind-resume) .1 : forall<a,b,e,c> (context : resume-context1<a,e,b,c>, result : a, local : c) -> e b
  = forall<a,b,e,c> fun<e>(context:resume-context1<a,e,b,c>, result:a, local:c){
    std/core/(.extern-resume.1){@}(context, result, local)
  };
public fun (.fast-resume) .1 : forall<a,b,e,c> (context : resume-context1<a,e,b,c>, result : a, local : c) -> e b
  = forall<a,b,e,c> fun<e>(context:resume-context1<a,e,b,c>, result:a, local:c){
    std/core/(.extern-resume.1){@}(context, result, local)
  };
public fun** resume .1 : forall<a,b,e,c> (context : resume-context1<a,e,b,c>, result : a, local : c) -> e b
  = forall<a,b,e,c> fun<e>(context:resume-context1<a,e,b,c>, result:a, local:c){
    std/core/(.bind-resume.1){4,3,bind}(context, result, local)
  };
// Returns a singleton list.
public fun single : forall<a> (x : a) -> list<a>
  = forall<a> fun(x:a){
    std/core/Cons(x, std/core/Nil)
  };
// Convert a string to lower-case
public fun to-lower : (s : string) -> string
  = fun(s:string){
    std/core/(.extern-to-lower){@}(s)
  };
fun xtrace : (message : string) -> ()
  = fun(message0:string){
    std/core/(.extern-xtrace){@}(message0)
  };
fun xtrace-any : forall<a> (message : string, x : a) -> ()
  = forall<a> fun(message0:string, x:a){
    std/core/(.extern-xtrace-any){@}(message0, x)
  };
// Get the value of the `Just` constructor or raise an exception
public fun unjust : forall<a> (m : maybe<a>) -> exn a
  = forall<a> fun<exn>(m:maybe<a>){
    match (m) {
      std/core/Just(x) -> x
      _ -> std/core/error-pattern{1,2,fast}("lib/std/core.kk(529, 3)", "unjust")
    }
  };
// Create a new vector of length `n`  with initial elements given by function `f` .
fun vector-init32 : forall<a> (n : int32, f : (int32) -> a) -> vector<a>
  = forall<a> fun(n:int32, f:(int32) -> a){
    std/core/(.extern-vector-init32){@}(n, f)
  };
// Substract two character codePoints
public fun (-) .3 : (c : char, d : char) -> total char
  = fun<total>(c:char, d:char){
    std/core/char{@}((std/core/(-){@}((std/core/int{@}(c)), (std/core/int{@}(d)))))
  };
public fun int .3 : (b : bool) -> int
  = fun(b:bool){
    match (b) {
      std/core/True() -> 1
      std/core/False() -> 0
    }
  };
public fun int .4 : (x : order) -> int
  = fun(x:order){
    match (x) {
      std/core/Lt() -> std/core/(-){@}(0, 1)
      std/core/Eq() -> 0
      std/core/Gt() -> 1
    }
  };
public fun (==) .4 : (x : order, y : order) -> bool
  = fun(x:order, y:order){
    std/core/(==.1){@}((std/core/int.4{0,1,fast}(x)), (std/core/int.4{0,1,fast}(y)))
  };
public fun (==) .5 : (x : bool, y : bool) -> bool
  = fun(x:bool, y:bool){
    match (x) {
      std/core/True() -> y
      std/core/False() -> std/core/(!){@}(y)
    }
  };
public fun (<) .4 : (x : order, y : order) -> bool
  = fun(x:order, y:order){
    std/core/(<.1){@}((std/core/int.4{0,1,fast}(x)), (std/core/int.4{0,1,fast}(y)))
  };
public fun (<) .5 : (x : bool, y : bool) -> bool
  = fun(x:bool, y:bool){
    std/core/(&&){@}((std/core/(!){@}(x)), y)
  };
public fun order : (i : int) -> order
  = fun(i:int){
    match ((std/core/(<.1){@}(i, 0))) {
      std/core/True() -> std/core/Lt
      std/core/False() -> match ((std/core/(>.1){@}(i, 0))) {
        std/core/True() -> std/core/Gt
        std/core/False() -> std/core/Eq
      }
    }
  };
// Compare two strings.
// Uses the character codes directly for comparison
public fun compare .4 : (x : string, y : string) -> order
  = fun(x:string, y:string){
    std/core/order{0,1,fast}((std/core/string-compare{0,2,fast}(x, y)))
  };
public fun (<) .6 : (x : string, y : string) -> bool
  = fun(x:string, y:string){
    std/core/(==.4){0,2,fast}((std/core/compare.4{0,2,fast}(x, y)), std/core/Lt)
  };
public fun (>) .3 : (x : order, y : order) -> bool
  = fun(x:order, y:order){
    std/core/(>.1){@}((std/core/int.4{0,1,fast}(x)), (std/core/int.4{0,1,fast}(y)))
  };
public fun (>) .4 : (x : bool, y : bool) -> bool
  = fun(x:bool, y:bool){
    std/core/(&&){@}(x, (std/core/(!){@}(y)))
  };
public fun (>) .5 : (x : string, y : string) -> bool
  = fun(x:string, y:string){
    std/core/(==.4){0,2,fast}((std/core/compare.4{0,2,fast}(x, y)), std/core/Gt)
  };
public fun compare .1 : (x : char, y : char) -> order
  = fun(x:char, y:char){
    match ((std/core/(<){@}(x, y))) {
      std/core/True() -> std/core/Lt
      std/core/False() -> match ((std/core/(>){@}(x, y))) {
        std/core/True() -> std/core/Gt
        std/core/False() -> std/core/Eq
      }
    }
  };
public fun compare .2 : (x : bool, y : bool) -> order
  = fun(x:bool, y:bool){
    match ((std/core/(<.5){0,2,fast}(x, y))) {
      std/core/True() -> std/core/Lt
      std/core/False() -> match ((std/core/(>.4){0,2,fast}(x, y))) {
        std/core/True() -> std/core/Gt
        std/core/False() -> std/core/Eq
      }
    }
  };
public fun compare .3 : (x : double, y : double) -> order
  = fun(x:double, y:double){
    match ((std/core/(<.3){@}(x, y))) {
      std/core/True() -> std/core/Lt
      std/core/False() -> match ((std/core/(>.2){@}(x, y))) {
        std/core/True() -> std/core/Gt
        std/core/False() -> std/core/Eq
      }
    }
  };
// Reverse a list.
public fun reverse : forall<a> (xs : list<a>) -> list<a>
  = forall<a> fun(xs:list<a>){
    std/core/reverse-append{1,2,fast}(xs, std/core/Nil)
  };
// Append two lists.
public fun (+) .4 : forall<a> (xs : list<a>, ys : list<a>) -> list<a>
  = forall<a> fun(xs:list<a>, ys:list<a>){
    // append using _constant_ stack space (by reversing the argument list)
    val rev-append : forall<b> (list<b>, list<b>) -> list<b>
      = forall<b> fun(xx:list<b>, yy:list<b>){
        match (xx) {
          std/core/Cons(z, zz) -> rev-append(zz, (std/core/Cons(z, yy)))
          _ -> yy
        }
      };;
    // append for the first `maxListStack` elements over the stack
    val append : forall<b> (int, list<b>, list<b>) -> list<b>
      = forall<b> fun(n:int, xx0:list<b>, yy0:list<b>){
        match ((std/core/(>.1){@}(n, std/core/maxListStack))) {
          std/core/True() -> rev-append((std/core/reverse{1,1,fast}(xx0)), yy0)
          std/core/False() -> match (xx0) {
            std/core/Cons(z0, zz0) -> std/core/Cons(z0, (append((std/core/(+){@}(n, 1)), zz0, yy0)))
            std/core/Nil() -> yy0
          }
        }
      };;
    match (ys) {
      std/core/Nil() -> xs
      _ -> match (xs) {
        std/core/Nil() -> ys
        _ -> append(0, xs, ys)
      }
    }
  };
// Add two character code points
public fun (+) .5 : (c : char, d : char) -> total char
  = fun<total>(c:char, d:char){
    std/core/char{@}((std/core/(+){@}((std/core/int{@}(c)), (std/core/int{@}(d)))))
  };
// Raise an integer `i` to the power of `exp`.
public fun (^) .1 : (i : int, exp : int) -> int
  = fun(i:int, exp:int){
    std/core/pow{0,2,fast}(i, exp)
  };
public fun (!=) .4 : (x : order, y : order) -> bool
  = fun(x:order, y:order){
    std/core/(!=.1){@}((std/core/int.4{0,1,fast}(x)), (std/core/int.4{0,1,fast}(y)))
  };
public fun (!=) .5 : (x : bool, y : bool) -> bool
  = fun(x:bool, y:bool){
    match (x) {
      std/core/True() -> std/core/(!){@}(y)
      std/core/False() -> y
    }
  };
public fun (<=) .4 : (x : order, y : order) -> bool
  = fun(x:order, y:order){
    std/core/(<=.1){@}((std/core/int.4{0,1,fast}(x)), (std/core/int.4{0,1,fast}(y)))
  };
public fun (<=) .5 : (x : bool, y : bool) -> bool
  = fun(x:bool, y:bool){
    std/core/(!){@}((std/core/(>.4){0,2,fast}(x, y)))
  };
public fun (<=) .6 : (x : string, y : string) -> bool
  = fun(x:string, y:string){
    std/core/(<.4){0,2,fast}((std/core/compare.4{0,2,fast}(x, y)), std/core/Gt)
  };
public fun (>=) .3 : (x : order, y : order) -> bool
  = fun(x:order, y:order){
    std/core/(>=.1){@}((std/core/int.4{0,1,fast}(x)), (std/core/int.4{0,1,fast}(y)))
  };
public fun (>=) .4 : (x : bool, y : bool) -> bool
  = fun(x:bool, y:bool){
    std/core/(!){@}((std/core/(<.5){0,2,fast}(x, y)))
  };
public fun (>=) .5 : (x : string, y : string) -> bool
  = fun(x:string, y:string){
    std/core/(>.3){0,2,fast}((std/core/compare.4{0,2,fast}(x, y)), std/core/Lt)
  };
// Get (zero-based) element `n`  of a list. Return a `:maybe` type.
public fun [] .1 : forall<a> (xs : list<a>, n : int) -> maybe<a>
  = forall<a> fun(xs:list<a>, n:int){
    match (xs) {
      std/core/Cons(x, xx) -> match ((std/core/(==.1){@}(n, 0))) {
        std/core/True() -> std/core/Just(x)
        std/core/False() -> std/core/([].1){1,2,fast}(xx, (std/core/(-){@}(n, 1)))
      }
      std/core/Nil() -> std/core/Nothing
    }
  };
public fun sign .1 : (d : double) -> order
  = fun(d:double){
    match ((std/core/(<.3){@}(d, 0.0))) {
      std/core/True() -> std/core/Lt
      std/core/False() -> match ((std/core/(>.2){@}(d, 0.0))) {
        std/core/True() -> std/core/Gt
        std/core/False() -> std/core/Eq
      }
    }
  };
// Is the integer positive (stricly greater than zero)
public fun pos? .1 : (i : int) -> bool
  = fun(i:int){
    std/core/(==.4){0,2,fast}((std/core/sign{@}(i)), std/core/Gt)
  };
// Is the value positive?
public fun pos? .2 : (d : double) -> bool
  = fun(d:double){
    std/core/(>.2){@}(d, 0.0)
  };
// Is a slice empty?
public fun empty? : (slice : sslice) -> bool
  = fun(slice0:sslice){
    std/core/(!){@}((std/core/pos?{@}((std/core/len{0,1,fast}(slice0)))))
  };
// Is a string empty?
public fun empty? .1 : (s : string) -> bool
  = fun(s:string){
    std/core/(==.3){@}(s, "")
  };
public fun (||) .1 : forall<a> (m1 : maybe<a>, m2 : maybe<a>) -> maybe<a>
  = forall<a> fun(m1:maybe<a>, m2:maybe<a>){
    match (m1) {
      std/core/Nothing() -> m2
      _ -> m1
    }
  };
// Choose a non-empty string
public fun (||) .2 : (x : string, y : string) -> string
  = fun(x:string, y:string){
    match ((std/core/empty?.1{0,1,fast}(x))) {
      std/core/True() -> y
      std/core/False() -> x
    }
  };
// Return the element at position `index` in vector `v`, or `Nothing` if out of bounds
public fun at : forall<a> (v : vector<a>, index : int) -> maybe<a>
  = forall<a> fun(v:vector<a>, index:int){
    val idx : int32
          = std/core/int32{@}(index);
    match ((std/core/(||){@}((std/core/(<.2){@}(idx, (std/core/int32{@}(0)))), (std/core/(<=.2){@}((std/core/length32{@}(v)), idx))))) {
      std/core/True() -> std/core/Nothing
      std/core/False() -> std/core/Just((std/core/unsafe-idx{@}(v, idx)))
    }
  };
// Do all elements satisfy a predicate ?
public fun* (.bind-all) : forall<a,e> (xs : list<a>, predicate : (a) -> e bool) -> e bool
  = forall<a,e> fun<e>(xs:list<a>, predicate:(a) -> e bool){
    match (xs) {
      std/core/Nil() -> std/core/True
      std/core/Cons(x, xx) -> std/core/bind{@}((predicate(x)), (fun<e>(.y.13:bool){
          match (.y.13) {
            std/core/True() -> std/core/(.bind-all){2,2,bind}(xx, predicate)
            std/core/False() -> std/core/False
          }
        }))
    }
  };
// Do all elements satisfy a predicate ?
public fun (.fast-all) : forall<a,e> (xs : list<a>, predicate : (a) -> e bool) -> e bool
  = forall<a,e> fun<e>(xs0:list<a>, predicate0:(a) -> e bool){
    match (xs0) {
      std/core/Nil() -> std/core/True
      std/core/Cons(x0, xx0) -> match ((predicate0(x0))) {
        std/core/True() -> std/core/(.fast-all){2,2,fast}(xx0, predicate0)
        std/core/False() -> std/core/False
      }
    }
  };
// Do all elements satisfy a predicate ?
public fun** all : forall<a,e> (xs : list<a>, predicate : (a) -> e bool) -> e bool
  = forall<a,e> fun<e>(xs1:list<a>, predicate1:(a) -> e bool){
    std/core/(.bind-all){2,2,bind}(xs1, predicate1)
  };
// Are there any elements in a list that satisfy a predicate ?
public fun* (.bind-any) : forall<a,e> (xs : list<a>, predicate : (a) -> e bool) -> e bool
  = forall<a,e> fun<e>(xs:list<a>, predicate:(a) -> e bool){
    match (xs) {
      std/core/Nil() -> std/core/False
      std/core/Cons(x, xx) -> std/core/bind{@}((predicate(x)), (fun<e>(.y.17:bool){
          match (.y.17) {
            std/core/True() -> std/core/True
            std/core/False() -> std/core/(.bind-any){2,2,bind}(xx, predicate)
          }
        }))
    }
  };
// Are there any elements in a list that satisfy a predicate ?
public fun (.fast-any) : forall<a,e> (xs : list<a>, predicate : (a) -> e bool) -> e bool
  = forall<a,e> fun<e>(xs0:list<a>, predicate0:(a) -> e bool){
    match (xs0) {
      std/core/Nil() -> std/core/False
      std/core/Cons(x0, xx0) -> match ((predicate0(x0))) {
        std/core/True() -> std/core/True
        std/core/False() -> std/core/(.fast-any){2,2,fast}(xx0, predicate0)
      }
    }
  };
// Are there any elements in a list that satisfy a predicate ?
public fun** any : forall<a,e> (xs : list<a>, predicate : (a) -> e bool) -> e bool
  = forall<a,e> fun<e>(xs1:list<a>, predicate1:(a) -> e bool){
    std/core/(.bind-any){2,2,bind}(xs1, predicate1)
  };
public fun dec : (i : int) -> int
  = fun(i:int){
    std/core/(-){@}(i, 1)
  };
public fun inc : (i : int) -> int
  = fun(i:int){
    std/core/(+){@}(i, 1)
  };
// Executes `action`  for each integer between `start`  upto `end`  (including both `start`  and `end` ).
// If `start > end`  the function returns without any call to `action` .
public fun* (.bind-for) : forall<e> (start : int, end : int, action : (int) -> e ()) -> e ()
  = forall<e> fun<e>(start0:int, end:int, action:(int) -> e ()){
    val rep : (i : int) -> e ()
      = fun<e>(i:int){
        match ((std/core/(<=.1){@}(i, end))) {
          std/core/True() -> std/core/bind{@}((action(i)), (fun<e>(_:()){
              (rep((std/core/unsafe-decreasing{@}((std/core/inc{0,1,fast}(i))))))
            }))
          std/core/False() -> std/core/()
        }
      };;
    ;
    rep(start0)
  };
// Executes `action`  for each integer between `start`  upto `end`  (including both `start`  and `end` ).
// If `start > end`  the function returns without any call to `action` .
public fun (.fast-for) : forall<e> (start : int, end : int, action : (int) -> e ()) -> e ()
  = forall<e> fun<e>(start0:int, end:int, action:(int) -> e ()){
    val rep : (i : int) -> e ()
      = fun<e>(i:int){
        match ((std/core/(<=.1){@}(i, end))) {
          std/core/True() -> val _ : ()
                                   = action(i);
          rep((std/core/unsafe-decreasing{@}((std/core/inc{0,1,fast}(i)))))
          std/core/False() -> std/core/()
        }
      };;
    ;
    rep(start0)
  };
// Executes `action`  for each integer between `start`  upto `end`  (including both `start`  and `end` ).
// If `start > end`  the function returns without any call to `action` .
public fun** for : forall<e> (start : int, end : int, action : (int) -> e ()) -> e ()
  = forall<e> fun<e>(start0:int, end:int, action:(int) -> e ()){
    std/core/(.bind-for){1,3,bind}(start0, end, action)
  };
fun decr : (i : int32) -> int32
  = fun(i:int32){
    std/core/(-.1){@}(i, (std/core/int32{@}(1)))
  };
fun incr : (i : int32) -> int32
  = fun(i:int32){
    std/core/(+.1){@}(i, (std/core/int32{@}(1)))
  };
// Executes `action`  for each integer between `start`  upto `end`  (including both `start`  and `end` ).
// If `start > end`  the function returns without any call to `action` .
fun* (.bind-for32) : forall<e> (start : int32, end : int32, action : (int32) -> e ()) -> e ()
  = forall<e> fun<e>(start0:int32, end:int32, action:(int32) -> e ()){
    val rep : (i : int32) -> e ()
      = fun<e>(i:int32){
        match ((std/core/(<=.2){@}(i, end))) {
          std/core/True() -> std/core/bind{@}((action(i)), (fun<e>(_:()){
              (rep((std/core/unsafe-decreasing{@}((std/core/incr{0,1,fast}(i))))))
            }))
          std/core/False() -> std/core/()
        }
      };;
    ;
    rep(start0)
  };
// Executes `action`  for each integer between `start`  upto `end`  (including both `start`  and `end` ).
// If `start > end`  the function returns without any call to `action` .
fun (.fast-for32) : forall<e> (start : int32, end : int32, action : (int32) -> e ()) -> e ()
  = forall<e> fun<e>(start0:int32, end:int32, action:(int32) -> e ()){
    val rep : (i : int32) -> e ()
      = fun<e>(i:int32){
        match ((std/core/(<=.2){@}(i, end))) {
          std/core/True() -> val _ : ()
                                   = action(i);
          rep((std/core/unsafe-decreasing{@}((std/core/incr{0,1,fast}(i)))))
          std/core/False() -> std/core/()
        }
      };;
    ;
    rep(start0)
  };
// Executes `action`  for each integer between `start`  upto `end`  (including both `start`  and `end` ).
// If `start > end`  the function returns without any call to `action` .
fun** for32 : forall<e> (start : int32, end : int32, action : (int32) -> e ()) -> e ()
  = forall<e> fun<e>(start0:int32, end:int32, action:(int32) -> e ()){
    std/core/(.bind-for32){1,3,bind}(start0, end, action)
  };
fun* (.bind-foreach-indexed32) : forall<a,e> (v : vector<a>, f : (a, int32) -> e ()) -> e ()
  = forall<a,e> fun<e>(v:vector<a>, f:(a, int32) -> e ()){
    std/core/(.bind-for32){1,3,bind}((std/core/int32{@}(0)), (std/core/decr{0,1,fast}((std/core/length32{@}(v)))), (fun<e>(i:int32){
        (f((std/core/unsafe-idx{@}(v, i)), i))
      }))
  };
fun (.fast-foreach-indexed32) : forall<a,e> (v : vector<a>, f : (a, int32) -> e ()) -> e ()
  = forall<a,e> fun<e>(v:vector<a>, f:(a, int32) -> e ()){
    std/core/(.fast-for32){1,3,fast}((std/core/int32{@}(0)), (std/core/decr{0,1,fast}((std/core/length32{@}(v)))), (fun<e>(i:int32){
        (f((std/core/unsafe-idx{@}(v, i)), i))
      }))
  };
fun** foreach-indexed32 : forall<a,e> (v : vector<a>, f : (a, int32) -> e ()) -> e ()
  = forall<a,e> fun<e>(v:vector<a>, f:(a, int32) -> e ()){
    std/core/(.bind-foreach-indexed32){2,2,bind}(v, f)
  };
// Returns the length of a list.
public fun length .1 : forall<a> (xs : list<a>) -> int
  = forall<a> fun(xs:list<a>){
    val len0 : forall<b> (int, list<b>) -> int
      = forall<b> fun(acc:int, ys:list<b>){
        match (ys) {
          std/core/Cons(_, yy) -> len0((std/core/(+){@}(acc, 1)), yy)
          std/core/Nil() -> acc
        }
      };;
    len0(0, xs)
  };
// Return the length of a vector.
public fun length .2 : forall<a> (v : vector<a>) -> int
  = forall<a> fun(v:vector<a>){
    std/core/int.1{@}((std/core/length32{@}(v)))
  };
// recurse using an accumulator using constant heap space
fun* (.bind-map-acc) : forall<a,b,e> (g : (int, a, list<a>) -> e b, n : int, acc : list<b>, ys : list<a>) -> e list<b>
  = forall<a,b,e> fun<e>(g:(int, a, list<a>) -> e b, n:int, acc:list<b>, ys:list<a>){
    match (ys) {
      std/core/Cons(x, xx) -> std/core/bind{@}((g(n, x, xx)), (fun<e>(.y.49:b){
          (std/core/(.bind-map-acc){3,4,bind}(g, (std/core/(+){@}(n, 1)), (std/core/Cons(.y.49, acc)), xx))
        }))
      std/core/Nil() -> std/core/reverse{1,1,fast}(acc)
    }
  };
// recurse using an accumulator using constant heap space
fun (.fast-map-acc) : forall<a,b,e> (g : (int, a, list<a>) -> e b, n : int, acc : list<b>, ys : list<a>) -> e list<b>
  = forall<a,b,e> fun<e>(g0:(int, a, list<a>) -> e b, n0:int, acc0:list<b>, ys0:list<a>){
    match (ys0) {
      std/core/Cons(x0, xx0) -> std/core/(.fast-map-acc){3,4,fast}(g0, (std/core/(+){@}(n0, 1)), (std/core/Cons((g0(n0, x0, xx0)), acc0)), xx0)
      std/core/Nil() -> std/core/reverse{1,1,fast}(acc0)
    }
  };
// recurse using an accumulator using constant heap space
fun** map-acc : forall<a,b,e> (g : (int, a, list<a>) -> e b, n : int, acc : list<b>, ys : list<a>) -> e list<b>
  = forall<a,b,e> fun<e>(g1:(int, a, list<a>) -> e b, n1:int, acc1:list<b>, ys1:list<a>){
    std/core/(.bind-map-acc){3,4,bind}(g1, n1, acc1, ys1)
  };
// Apply a function `f`  to each element of the input list in sequence where takes
// both the index of the current element, the element itself, and the tail list as arguments.
public fun* (.bind-map-indexed-peek) : forall<a,b,e> (xs : list<a>, f : (idx : int, value : a, rest : list<a>) -> e b) -> e list<b>
  = forall<a,b,e> fun<e>(xs:list<a>, f:(idx : int, value : a, rest : list<a>) -> e b){
    // recurse for the first `maxListStack` elements over the stack (to avoid extra heap allocation)
    fun* (.bind-map-iter) : forall<c,d,e1> (g : (int, c, list<c>) -> e1 d, n : int, ys : list<c>) -> e1 list<d>
      = forall<c,d,e1> fun<e1>(g:(int, c, list<c>) -> e1 d, n:int, ys:list<c>){
        match ((std/core/(>.1){@}(n, std/core/maxListStack))) {
          std/core/True() -> std/core/(.bind-map-acc){3,4,bind}(g, n, std/core/Nil, ys)
          std/core/False() -> match (ys) {
            std/core/Cons(x, xx) -> std/core/bind{@}((g(n, x, xx)), (fun<e1>(.y.58:d){
                (std/core/bind{@}((.bind-map-iter{3,3,bind}(g, (std/core/(+){@}(n, 1)), xx)), (fun<e1>(.y.62:list<d>){
                    (std/core/Cons(.y.58, .y.62))
                  })))
              }))
            std/core/Nil() -> std/core/Nil
          }
        }
      };;
    .bind-map-iter{3,3,bind}(f, 0, xs)
  };
// Apply a function `f`  to each element of the input list in sequence where takes
// both the index of the current element, the element itself, and the tail list as arguments.
public fun (.fast-map-indexed-peek) : forall<a,b,e> (xs : list<a>, f : (idx : int, value : a, rest : list<a>) -> e b) -> e list<b>
  = forall<a,b,e> fun<e>(xs:list<a>, f:(idx : int, value : a, rest : list<a>) -> e b){
    // recurse for the first `maxListStack` elements over the stack (to avoid extra heap allocation)
    fun (.fast-map-iter) : forall<c,d,e1> (g : (int, c, list<c>) -> e1 d, n : int, ys : list<c>) -> e1 list<d>
      = forall<c,d,e1> fun<e1>(g:(int, c, list<c>) -> e1 d, n:int, ys:list<c>){
        match ((std/core/(>.1){@}(n, std/core/maxListStack))) {
          std/core/True() -> std/core/(.fast-map-acc){3,4,fast}(g, n, std/core/Nil, ys)
          std/core/False() -> match (ys) {
            std/core/Cons(x, xx) -> std/core/Cons((g(n, x, xx)), (.fast-map-iter{3,3,fast}(g, (std/core/(+){@}(n, 1)), xx)))
            std/core/Nil() -> std/core/Nil
          }
        }
      };;
    .fast-map-iter{3,3,fast}(f, 0, xs)
  };
// Apply a function `f`  to each element of the input list in sequence where takes
// both the index of the current element, the element itself, and the tail list as arguments.
public fun** map-indexed-peek : forall<a,b,e> (xs : list<a>, f : (idx : int, value : a, rest : list<a>) -> e b) -> e list<b>
  = forall<a,b,e> fun<e>(xs:list<a>, f:(idx : int, value : a, rest : list<a>) -> e b){
    std/core/(.bind-map-indexed-peek){3,2,bind}(xs, f)
  };
public fun* (.bind-map) : forall<a,b,e> (m : maybe<a>, f : (a) -> e b) -> e maybe<b>
  = forall<a,b,e> fun<e>(m:maybe<a>, f:(a) -> e b){
    match (m) {
      std/core/Nothing() -> std/core/Nothing
      std/core/Just(x) -> std/core/bind{@}((f(x)), (fun<e>(.y.79:b){
          (std/core/Just(.y.79))
        }))
    }
  };
public fun (.fast-map) : forall<a,b,e> (m : maybe<a>, f : (a) -> e b) -> e maybe<b>
  = forall<a,b,e> fun<e>(m:maybe<a>, f:(a) -> e b){
    match (m) {
      std/core/Nothing() -> std/core/Nothing
      std/core/Just(x) -> std/core/Just((f(x)))
    }
  };
public fun** map : forall<a,b,e> (m : maybe<a>, f : (a) -> e b) -> e maybe<b>
  = forall<a,b,e> fun<e>(m:maybe<a>, f:(a) -> e b){
    std/core/(.bind-map){3,2,bind}(m, f)
  };
// Returns an integer list of increasing elements from `lo`  to `hi`
// (including both `lo`  and `hi` ).
// If `lo > hi`  the function returns the empty list.
public fun list : (lo : int, hi : int) -> total list<int>
  = fun<total>(lo:int, hi:int){
    fun** enumerate : (low : int, high : int, acc : list<int>) -> list<int>
      = fun(low:int, high:int, acc:list<int>){
        match ((std/core/(>.1){@}(low, high))) {
          std/core/True() -> acc
          std/core/False() -> enumerate{0,3,fast}(low, (std/core/unsafe-decreasing{@}((std/core/(-){@}(high, 1)))), (std/core/Cons(high, acc)))
        }
      };;
    enumerate{0,3,fast}(lo, hi, std/core/Nil)
  };
// Applies a function `f` to list of increasing elements from `lo`  to `hi`
// (including both `lo`  and `hi` ).
// If `lo > hi`  the function returns the empty list.
public fun* (.bind-list) .1 : forall<a,e> (lo : int, hi : int, f : (int) -> e a) -> e list<a>
  = forall<a,e> fun<e>(lo:int, hi:int, f:(int) -> e a){
    val enumerate : (low : int, high : int, acc : list<a>) -> e list<a>
      = fun<e>(low:int, high:int, acc:list<a>){
        match ((std/core/(>.1){@}(low, high))) {
          std/core/True() -> acc
          std/core/False() -> std/core/bind{@}((f(high)), (fun<e>(.y.89:a){
              (enumerate(low, (std/core/unsafe-decreasing{@}((std/core/(-){@}(high, 1)))), (std/core/Cons(.y.89, acc))))
            }))
        }
      };;
    ;
    enumerate(lo, hi, std/core/Nil)
  };
// Applies a function `f` to list of increasing elements from `lo`  to `hi`
// (including both `lo`  and `hi` ).
// If `lo > hi`  the function returns the empty list.
public fun (.fast-list) .1 : forall<a,e> (lo : int, hi : int, f : (int) -> e a) -> e list<a>
  = forall<a,e> fun<e>(lo:int, hi:int, f:(int) -> e a){
    val enumerate : (low : int, high : int, acc : list<a>) -> e list<a>
      = fun<e>(low:int, high:int, acc:list<a>){
        match ((std/core/(>.1){@}(low, high))) {
          std/core/True() -> acc
          std/core/False() -> enumerate(low, (std/core/unsafe-decreasing{@}((std/core/(-){@}(high, 1)))), (std/core/Cons((f(high)), acc)))
        }
      };;
    ;
    enumerate(lo, hi, std/core/Nil)
  };
// Applies a function `f` to list of increasing elements from `lo`  to `hi`
// (including both `lo`  and `hi` ).
// If `lo > hi`  the function returns the empty list.
public fun** list .1 : forall<a,e> (lo : int, hi : int, f : (int) -> e a) -> e list<a>
  = forall<a,e> fun<e>(lo:int, hi:int, f:(int) -> e a){
    std/core/(.bind-list.1){2,3,bind}(lo, hi, f)
  };
// Apply a function `f`  to each element of the input list in sequence.
public fun* (.bind-map) .5 : forall<a,b,e> (xs : list<a>, f : (a) -> e b) -> e list<b>
  = forall<a,b,e> fun<e>(xs:list<a>, f:(a) -> e b){
    std/core/(.bind-map-indexed-peek){3,2,bind}(xs, (fun<e>(i:int, x:a, xx:list<a>){
        (f(x))
      }))
  };
// Apply a function `f`  to each element of the input list in sequence.
public fun (.fast-map) .5 : forall<a,b,e> (xs : list<a>, f : (a) -> e b) -> e list<b>
  = forall<a,b,e> fun<e>(xs:list<a>, f:(a) -> e b){
    std/core/(.fast-map-indexed-peek){3,2,fast}(xs, (fun<e>(i:int, x:a, xx:list<a>){
        (f(x))
      }))
  };
// Apply a function `f`  to each element of the input list in sequence.
public fun** map .5 : forall<a,b,e> (xs : list<a>, f : (a) -> e b) -> e list<b>
  = forall<a,b,e> fun<e>(xs:list<a>, f:(a) -> e b){
    std/core/(.bind-map.5){3,2,bind}(xs, f)
  };
// Create a list of characters from `lo`  to `hi`  (inclusive).
public fun list .2 : (lo : char, hi : char) -> total list<char>
  = fun<total>(lo:char, hi:char){
    std/core/map.5{3,2,poly}((std/core/list{0,2,fast}((std/core/int{@}(lo)), (std/core/int{@}(hi)))), std/core/char{@})
  };
// Convert a `:maybe` type to a list type.
public fun list .3 : forall<a> (m : maybe<a>) -> list<a>
  = forall<a> fun(m:maybe<a>){
    match (m) {
      std/core/Nothing() -> std/core/Nil
      std/core/Just(x) -> std/core/Cons(x, std/core/Nil)
    }
  };
// Convert a string to a list of characters
public fun list .4 : (s : string) -> total list<char>
  = fun<total>(s:string){
    std/core/(.extern-list){@}(s)
  };
// Convert a vector to a list.
public fun list .5 : forall<a> (v : vector<a>) -> list<a>
  = forall<a> fun(v:vector<a>){
    std/core/vlist{1,2,fast}(v, std/core/None)
  };
// Map over the `Right` component of an `:either` type.
public fun* (.bind-map) .1 : forall<a,b,c,e> (e : either<a,b>, f : (b) -> e c) -> e either<a,c>
  = forall<a,b,c,e> fun<e>(e:either<a,b>, f:(b) -> e c){
    match (e) {
      std/core/Right(x) -> std/core/bind{@}((f(x)), (fun<e>(.y.96:c){
          (std/core/Right(.y.96))
        }))
      std/core/Left(x0) -> std/core/Left(x0)
    }
  };
// Map over the `Right` component of an `:either` type.
public fun (.fast-map) .1 : forall<a,b,c,e> (e : either<a,b>, f : (b) -> e c) -> e either<a,c>
  = forall<a,b,c,e> fun<e>(e:either<a,b>, f:(b) -> e c){
    match (e) {
      std/core/Right(x) -> std/core/Right((f(x)))
      std/core/Left(x0) -> std/core/Left(x0)
    }
  };
// Map over the `Right` component of an `:either` type.
public fun** map .1 : forall<a,b,c,e> (e : either<a,b>, f : (b) -> e c) -> e either<a,c>
  = forall<a,b,c,e> fun<e>(e:either<a,b>, f:(b) -> e c){
    std/core/(.bind-map.1){4,2,bind}(e, f)
  };
public fun* (.bind-map) .2 : forall<a,b,e> (t : (a, a), f : (a) -> e b) -> e (b, b)
  = forall<a,b,e> fun<e>(t:(a, a), f:(a) -> e b){
    std/core/bind{@}((f((std/core/fst{2,1,fast}(t)))), (fun<e>(.y.101:b){
        (std/core/bind{@}((f((std/core/snd{2,1,fast}(t)))), (fun<e>(.y.103:b){
            (std/core/(,)(.y.101, .y.103))
          })))
      }))
  };
public fun (.fast-map) .2 : forall<a,b,e> (t : (a, a), f : (a) -> e b) -> e (b, b)
  = forall<a,b,e> fun<e>(t:(a, a), f:(a) -> e b){
    std/core/(,)((f((std/core/fst{2,1,fast}(t)))), (f((std/core/snd{2,1,fast}(t)))))
  };
public fun** map .2 : forall<a,b,e> (t : (a, a), f : (a) -> e b) -> e (b, b)
  = forall<a,b,e> fun<e>(t:(a, a), f:(a) -> e b){
    std/core/(.bind-map.2){3,2,bind}(t, f)
  };
public fun* (.bind-map) .3 : forall<a,b,e> (t : (a, a, a), f : (a) -> e b) -> e (b, b, b)
  = forall<a,b,e> fun<e>(t:(a, a, a), f:(a) -> e b){
    std/core/bind{@}((f((std/core/fst.1{3,1,fast}(t)))), (fun<e>(.y.106:b){
        (std/core/bind{@}((f((std/core/snd.1{3,1,fast}(t)))), (fun<e>(.y.108:b){
            (std/core/bind{@}((f((std/core/thd{3,1,fast}(t)))), (fun<e>(.y.110:b){
                (std/core/(,,)(.y.106, .y.108, .y.110))
              })))
          })))
      }))
  };
public fun (.fast-map) .3 : forall<a,b,e> (t : (a, a, a), f : (a) -> e b) -> e (b, b, b)
  = forall<a,b,e> fun<e>(t:(a, a, a), f:(a) -> e b){
    std/core/(,,)((f((std/core/fst.1{3,1,fast}(t)))), (f((std/core/snd.1{3,1,fast}(t)))), (f((std/core/thd{3,1,fast}(t)))))
  };
public fun** map .3 : forall<a,b,e> (t : (a, a, a), f : (a) -> e b) -> e (b, b, b)
  = forall<a,b,e> fun<e>(t:(a, a, a), f:(a) -> e b){
    std/core/(.bind-map.3){3,2,bind}(t, f)
  };
public fun* (.bind-map) .4 : forall<a,b,e> (t : (a, a, a, a), f : (a) -> e b) -> e (b, b, b, b)
  = forall<a,b,e> fun<e>(t:(a, a, a, a), f:(a) -> e b){
    std/core/bind{@}((f((std/core/fst.2{4,1,fast}(t)))), (fun<e>(.y.113:b){
        (std/core/bind{@}((f((std/core/snd.2{4,1,fast}(t)))), (fun<e>(.y.115:b){
            (std/core/bind{@}((f((std/core/thd.1{4,1,fast}(t)))), (fun<e>(.y.117:b){
                (std/core/bind{@}((f((std/core/field4{4,1,fast}(t)))), (fun<e>(.y.119:b){
                    (std/core/(,,,)(.y.113, .y.115, .y.117, .y.119))
                  })))
              })))
          })))
      }))
  };
public fun (.fast-map) .4 : forall<a,b,e> (t : (a, a, a, a), f : (a) -> e b) -> e (b, b, b, b)
  = forall<a,b,e> fun<e>(t:(a, a, a, a), f:(a) -> e b){
    std/core/(,,,)((f((std/core/fst.2{4,1,fast}(t)))), (f((std/core/snd.2{4,1,fast}(t)))), (f((std/core/thd.1{4,1,fast}(t)))), (f((std/core/field4{4,1,fast}(t)))))
  };
public fun** map .4 : forall<a,b,e> (t : (a, a, a, a), f : (a) -> e b) -> e (b, b, b, b)
  = forall<a,b,e> fun<e>(t:(a, a, a, a), f:(a) -> e b){
    std/core/(.bind-map.4){3,2,bind}(t, f)
  };
// Apply a function `f` to each character in a string
public fun* (.bind-map) .6 : forall<e> (s : string, f : (char) -> e char) -> e string
  = forall<e> fun<e>(s:string, f:(char) -> e char){
    std/core/bind{@}((std/core/(.bind-map.5){3,2,bind}((std/core/list.4{0,1,fast}(s)), f)), std/core/string.2{0,1,fast})
  };
// Apply a function `f` to each character in a string
public fun (.fast-map) .6 : forall<e> (s : string, f : (char) -> e char) -> e string
  = forall<e> fun<e>(s:string, f:(char) -> e char){
    std/core/string.2{0,1,fast}((std/core/(.fast-map.5){3,2,fast}((std/core/list.4{0,1,fast}(s)), f)))
  };
// Apply a function `f` to each character in a string
public fun** map .6 : forall<e> (s : string, f : (char) -> e char) -> e string
  = forall<e> fun<e>(s:string, f:(char) -> e char){
    std/core/(.bind-map.6){1,2,bind}(s, f)
  };
// Apply a total function `f` to each element in a vector `v`
public fun* (.bind-map) .7 : forall<a,b,e> (v : vector<a>, f : (a) -> e b) -> e vector<b>
  = forall<a,b,e> fun<e>(v:vector<a>, f:(a) -> e b){
    val w.26018 : vector<b>
          = std/core/unsafe-vector{@}((std/core/int32{@}((std/core/length.2{1,1,fast}(v)))));
    std/core/bind{@}((std/core/(.bind-foreach-indexed32){2,2,bind}(v, (fun<e>(x:a, i:int32){
          (std/core/bind{@}((f(x)), (fun<e>(.y.128:b){
              (std/core/unsafe-assign{@}(w.26018, i, .y.128))
            })))
        }))), (fun<e>(_:()){
        w.26018
      }))
  };
// Apply a total function `f` to each element in a vector `v`
public fun (.fast-map) .7 : forall<a,b,e> (v : vector<a>, f : (a) -> e b) -> e vector<b>
  = forall<a,b,e> fun<e>(v:vector<a>, f:(a) -> e b){
    val w : vector<b>
      = std/core/unsafe-vector{@}((std/core/int32{@}((std/core/length.2{1,1,fast}(v)))));;
    val _ : ()
      = std/core/(.fast-foreach-indexed32){2,2,fast}(v, (fun<e>(x:a, i:int32){
          (std/core/unsafe-assign{@}(w, i, (f(x))))
        }));;
    w
  };
// Apply a total function `f` to each element in a vector `v`
public fun** map .7 : forall<a,b,e> (v : vector<a>, f : (a) -> e b) -> e vector<b>
  = forall<a,b,e> fun<e>(v:vector<a>, f:(a) -> e b){
    std/core/(.bind-map.7){3,2,bind}(v, f)
  };
// Return the maximum of two integers
public fun max : (i : int, j : int) -> int
  = fun(i:int, j:int){
    match ((std/core/(>=.1){@}(i, j))) {
      std/core/True() -> i
      std/core/False() -> j
    }
  };
// Returns the largest of two doubles
public fun max .1 : (x : double, y : double) -> double
  = fun(x:double, y:double){
    match ((std/core/(>=.2){@}(x, y))) {
      std/core/True() -> x
      std/core/False() -> y
    }
  };
// Return the minimum of two integers
public fun min : (i : int, j : int) -> int
  = fun(i:int, j:int){
    match ((std/core/(<=.1){@}(i, j))) {
      std/core/True() -> i
      std/core/False() -> j
    }
  };
// Returns the smallest of two doubles
public fun min .1 : (x : double, y : double) -> double
  = fun(x:double, y:double){
    match ((std/core/(<=.3){@}(x, y))) {
      std/core/True() -> x
      std/core/False() -> y
    }
  };
// Fold a list from the left, i.e. `foldl([1,2],0,(+)) == (0+1)+2`
// Since `foldl` is tail recursive, it is preferred over `foldr` when using an associative function `f`
public fun* (.bind-foldl) : forall<a,b,e> (list<a>, b, (b, a) -> e b) -> e b
  = forall<a,b,e> fun<e>(xs:list<a>, z:b, f:(b, a) -> e b){
    match (xs) {
      std/core/Cons(x, xx) -> std/core/bind{@}((f(z, x)), (fun<e>(.y.131:b){
          (std/core/(.bind-foldl){3,3,bind}(xx, .y.131, f))
        }))
      std/core/Nil() -> z
    }
  };
// Fold a list from the left, i.e. `foldl([1,2],0,(+)) == (0+1)+2`
// Since `foldl` is tail recursive, it is preferred over `foldr` when using an associative function `f`
public fun (.fast-foldl) : forall<a,b,e> (list<a>, b, (b, a) -> e b) -> e b
  = forall<a,b,e> fun<e>(xs0:list<a>, z0:b, f0:(b, a) -> e b){
    match (xs0) {
      std/core/Cons(x0, xx0) -> std/core/(.fast-foldl){3,3,fast}(xx0, (f0(z0, x0)), f0)
      std/core/Nil() -> z0
    }
  };
// Fold a list from the left, i.e. `foldl([1,2],0,(+)) == (0+1)+2`
// Since `foldl` is tail recursive, it is preferred over `foldr` when using an associative function `f`
public fun** foldl : forall<a,b,e> (list<a>, b, (b, a) -> e b) -> e b
  = forall<a,b,e> fun<e>(xs1:list<a>, z1:b, f1:(b, a) -> e b){
    std/core/(.bind-foldl){3,3,bind}(xs1, z1, f1)
  };
// Return the sum of a list of integers
public fun sum : (xs : list<int>) -> int
  = fun(xs:list<int>){
    std/core/foldl{3,3,poly}(xs, 0, (fun(x:int, y:int){
        (std/core/(+){@}(x, y))
      }))
  };
// Catch any exception raised in `action` and handle it.
// Use `on-exn` or `on-exit` when appropiate.
public fun* (.bind-try) : forall<a,e> (action : () -> <exn|e> a, hndl : (exception) -> e a) -> e a
  = forall<a,e> fun<e>(action:() -> <exn|e> a, hndl:(exception) -> e a){
    std/core/(.extern-try){@}(action, hndl)
  };
// Catch any exception raised in `action` and handle it.
// Use `on-exn` or `on-exit` when appropiate.
public fun (.fast-try) : forall<a,e> (action : () -> <exn|e> a, hndl : (exception) -> e a) -> e a
  = forall<a,e> fun<e>(action:() -> <exn|e> a, hndl:(exception) -> e a){
    std/core/(.extern-try){@}(action, hndl)
  };
// Catch any exception raised in `action` and handle it.
// Use `on-exn` or `on-exit` when appropiate.
public fun** try : forall<a,e> (action : () -> <exn|e> a, hndl : (exception) -> e a) -> e a
  = forall<a,e> fun<e>(action:() -> <exn|e> a, hndl:(exception) -> e a){
    std/core/(.bind-try){2,2,bind}(action, hndl)
  };
// Transform an exception effect to a `:try` type.
public fun* (.bind-try) .1 : forall<a,e> (action : () -> <exn|e> a) -> e try<a>
  = forall<a,e> fun<e>(action:() -> <exn|e> a){
    std/core/(.bind-try){2,2,bind}((fun<<exn|e>>(){
        (std/core/bind{@}((action()), (fun<<exn|e>>(.y.135:a){
            (std/core/Ok(.y.135))
          })))
      }), (fun<e>(exception0:exception){
        (std/core/lift{@}((std/core/Exn(exception0))))
      }))
  };
// Transform an exception effect to a `:try` type.
public fun (.fast-try) .1 : forall<a,e> (action : () -> <exn|e> a) -> e try<a>
  = forall<a,e> fun<e>(action:() -> <exn|e> a){
    std/core/(.fast-try){2,2,fast}((fun<<exn|e>>(){
        (std/core/Ok((action())))
      }), std/core/Exn)
  };
// Transform an exception effect to a `:try` type.
public fun** try .1 : forall<a,e> (action : () -> <exn|e> a) -> e try<a>
  = forall<a,e> fun<e>(action:() -> <exn|e> a){
    std/core/(.bind-try.1){2,1,bind}(action)
  };
fun* (.bind-zipwith-acc) : forall<a,b,c,e> ((int, a, b) -> e c, int, list<c>, list<a>, list<b>) -> e list<c>
  = forall<a,b,c,e> fun<e>(f:(int, a, b) -> e c, i:int, acc:list<c>, xs:list<a>, ys:list<b>){
    match (xs) {
      std/core/Nil() -> std/core/reverse{1,1,fast}(acc)
      std/core/Cons(x, xx) -> match (ys) {
        std/core/Nil() -> std/core/reverse{1,1,fast}(acc)
        std/core/Cons(y, yy) -> std/core/bind{@}((f(i, x, y)), (fun<e>(.y.143:c){
            (std/core/(.bind-zipwith-acc){4,5,bind}(f, (std/core/(+){@}(i, 1)), (std/core/Cons(.y.143, acc)), xx, yy))
          }))
      }
    }
  };
fun (.fast-zipwith-acc) : forall<a,b,c,e> ((int, a, b) -> e c, int, list<c>, list<a>, list<b>) -> e list<c>
  = forall<a,b,c,e> fun<e>(f0:(int, a, b) -> e c, i0:int, acc0:list<c>, xs0:list<a>, ys0:list<b>){
    match (xs0) {
      std/core/Nil() -> std/core/reverse{1,1,fast}(acc0)
      std/core/Cons(x0, xx0) -> match (ys0) {
        std/core/Nil() -> std/core/reverse{1,1,fast}(acc0)
        std/core/Cons(y0, yy0) -> std/core/(.fast-zipwith-acc){4,5,fast}(f0, (std/core/(+){@}(i0, 1)), (std/core/Cons((f0(i0, x0, y0)), acc0)), xx0, yy0)
      }
    }
  };
fun** zipwith-acc : forall<a,b,c,e> ((int, a, b) -> e c, int, list<c>, list<a>, list<b>) -> e list<c>
  = forall<a,b,c,e> fun<e>(f1:(int, a, b) -> e c, i1:int, acc1:list<c>, xs1:list<a>, ys1:list<b>){
    std/core/(.bind-zipwith-acc){4,5,bind}(f1, i1, acc1, xs1, ys1)
  };
fun* (.bind-zipwith-iter) : forall<a,b,c,e> ((int, a, b) -> e c, int, list<a>, list<b>) -> e list<c>
  = forall<a,b,c,e> fun<e>(f:(int, a, b) -> e c, i:int, xs:list<a>, ys:list<b>){
    match ((std/core/(>.1){@}(i, std/core/maxListStack))) {
      std/core/True() -> std/core/(.bind-zipwith-acc){4,5,bind}(f, i, std/core/Nil, xs, ys)
      std/core/False() -> match (xs) {
        std/core/Nil() -> std/core/Nil
        std/core/Cons(x, xx) -> match (ys) {
          std/core/Nil() -> std/core/Nil
          std/core/Cons(y, yy) -> std/core/bind{@}((f(i, x, y)), (fun<e>(.y.152:c){
              (std/core/bind{@}((std/core/(.bind-zipwith-iter){4,4,bind}(f, (std/core/(+){@}(i, 1)), xx, yy)), (fun<e>(.y.156:list<c>){
                  (std/core/Cons(.y.152, .y.156))
                })))
            }))
        }
      }
    }
  };
fun (.fast-zipwith-iter) : forall<a,b,c,e> ((int, a, b) -> e c, int, list<a>, list<b>) -> e list<c>
  = forall<a,b,c,e> fun<e>(f0:(int, a, b) -> e c, i0:int, xs0:list<a>, ys0:list<b>){
    match ((std/core/(>.1){@}(i0, std/core/maxListStack))) {
      std/core/True() -> std/core/(.fast-zipwith-acc){4,5,fast}(f0, i0, std/core/Nil, xs0, ys0)
      std/core/False() -> match (xs0) {
        std/core/Nil() -> std/core/Nil
        std/core/Cons(x0, xx0) -> match (ys0) {
          std/core/Nil() -> std/core/Nil
          std/core/Cons(y0, yy0) -> std/core/Cons((f0(i0, x0, y0)), (std/core/(.fast-zipwith-iter){4,4,fast}(f0, (std/core/(+){@}(i0, 1)), xx0, yy0)))
        }
      }
    }
  };
fun** zipwith-iter : forall<a,b,c,e> ((int, a, b) -> e c, int, list<a>, list<b>) -> e list<c>
  = forall<a,b,c,e> fun<e>(f1:(int, a, b) -> e c, i1:int, xs1:list<a>, ys1:list<b>){
    std/core/(.bind-zipwith-iter){4,4,bind}(f1, i1, xs1, ys1)
  };
// Zip two lists together by apply a function `f` to all corresponding elements
// and their index in the list.
// The returned list is only as long as the smallest input list.
public fun* (.bind-zipwith-indexed) : forall<a,b,c,e> (xs : list<a>, ys : list<b>, f : (int, a, b) -> e c) -> e list<c>
  = forall<a,b,c,e> fun<e>(xs:list<a>, ys:list<b>, f:(int, a, b) -> e c){
    std/core/(.bind-zipwith-iter){4,4,bind}(f, 0, xs, ys)
  };
// Zip two lists together by apply a function `f` to all corresponding elements
// and their index in the list.
// The returned list is only as long as the smallest input list.
public fun (.fast-zipwith-indexed) : forall<a,b,c,e> (xs : list<a>, ys : list<b>, f : (int, a, b) -> e c) -> e list<c>
  = forall<a,b,c,e> fun<e>(xs:list<a>, ys:list<b>, f:(int, a, b) -> e c){
    std/core/(.fast-zipwith-iter){4,4,fast}(f, 0, xs, ys)
  };
// Zip two lists together by apply a function `f` to all corresponding elements
// and their index in the list.
// The returned list is only as long as the smallest input list.
public fun** zipwith-indexed : forall<a,b,c,e> (xs : list<a>, ys : list<b>, f : (int, a, b) -> e c) -> e list<c>
  = forall<a,b,c,e> fun<e>(xs:list<a>, ys:list<b>, f:(int, a, b) -> e c){
    std/core/(.bind-zipwith-indexed){4,3,bind}(xs, ys, f)
  };
// Zip two lists together by pairing the corresponding elements.
// The returned list is only as long as the smallest input list.
public fun zip : forall<a,b> (xs : list<a>, ys : list<b>) -> list<(a, b)>
  = forall<a,b> fun(xs:list<a>, ys:list<b>){
    std/core/zipwith-indexed{4,3,poly}(xs, ys, (fun(i:int, x:a, y:b){
        (std/core/(,)(x, y))
      }))
  };
// O(1). Return the string slice from the end of `slice` argument
// to the end of the string.
public fun after : (slice : sslice) -> sslice
  = fun(slice0:sslice){
    match (slice0) {
      std/core/Sslice(s, start0, len0) -> std/core/Sslice(s, (std/core/(+.1){@}(start0, len0)), (std/core/(-.1){@}((std/core/length{@}(s)), (std/core/(+.1){@}(start0, len0)))))
    }
  };
// Is the character a lower-case ASCII character ?
public fun lower? : (c : char) -> bool
  = fun(c:char){
    std/core/(&&){@}((std/core/(>=){@}(c, 'a')), (std/core/(<=){@}(c, 'z')))
  };
// Is the character an upper-case ASCII character ?
public fun upper? : (c : char) -> bool
  = fun(c:char){
    std/core/(&&){@}((std/core/(>=){@}(c, 'A')), (std/core/(<=){@}(c, 'Z')))
  };
// Is the character an ASCII letter ?
public fun alpha? : (c : char) -> bool
  = fun(c:char){
    std/core/(||){@}((std/core/lower?{0,1,fast}(c)), (std/core/upper?{0,1,fast}(c)))
  };
// Is the character an ASCII digit ?
public fun digit? : (c : char) -> bool
  = fun(c:char){
    std/core/(&&){@}((std/core/(>=){@}(c, '0')), (std/core/(<=){@}(c, '9')))
  };
// Is the character ASCII letter or digit?
public fun alpha-num? : (c : char) -> bool
  = fun(c:char){
    std/core/(||){@}((std/core/alpha?{0,1,fast}(c)), (std/core/digit?{0,1,fast}(c)))
  };
// Is the character an ASCII character, e.g. `c <= '\x7F'`  ?
public fun ascii? : (c : char) -> bool
  = fun(c:char){
    std/core/(<=){@}(c, '\DEL')
  };
public fun throw : forall<a> (exn : exception) -> exn a
  = forall<a> fun<exn>(exn:exception){
    std/core/(.extern-throw){@}(exn)
  };
// Throw an exception
public fun throw .1 : forall<a> (message : string, err : ?exception-info) -> exn a
  = forall<a> fun<exn>(message0:string, err:?exception-info){
    val .err.13041 : exception-info
          = match (err) {
            std/core/Optional(.err.13042) -> .err.13042
            _ -> std/core/Error
          };
    std/core/throw{1,1,fast}((std/core/exception{0,2,fast}(message0, .err.13041)))
  };
// Raise an exception with a specified message.
public fun error : forall<a> (message : string) -> exn a
  = forall<a> fun<exn>(message0:string){
    std/core/throw.1{1,2,fast}(message0, (std/core/Optional(std/core/Error)))
  };
// _Unsafe_. This function removes the exception effect (`:exn`) from the effect of an action
public fun* (.bind-unsafe-noexn) : forall<a,e> (action : () -> <exn|e> a) -> e a
  = forall<a,e> fun<e>(action:() -> <exn|e> a){
    std/core/unsafe-total{2,1,fast}(action)
  };
// _Unsafe_. This function removes the exception effect (`:exn`) from the effect of an action
public fun (.fast-unsafe-noexn) : forall<a,e> (action : () -> <exn|e> a) -> e a
  = forall<a,e> fun<e>(action:() -> <exn|e> a){
    std/core/unsafe-total{2,1,fast}(action)
  };
// _Unsafe_. This function removes the exception effect (`:exn`) from the effect of an action
public fun** unsafe-noexn : forall<a,e> (action : () -> <exn|e> a) -> e a
  = forall<a,e> fun<e>(action:() -> <exn|e> a){
    std/core/(.bind-unsafe-noexn){2,1,bind}(action)
  };
public fun assert : (message : string, condition : bool) -> ()
  = fun(message0:string, condition:bool){
    match ((std/core/(!){@}(condition))) {
      std/core/True() -> std/core/unsafe-noexn{2,1,poly}((fun<exn>(){
        (std/core/throw.1{1,2,fast}(message0, (std/core/Optional(std/core/Assert))))
      }))
      std/core/False() -> std/core/()
    }
  };
// Convert an int to a boolean, using `False` for 0 and `True` otherwise.
public fun bool : (i : int) -> bool
  = fun(i:int){
    std/core/(!=.1){@}(i, 0)
  };
// Convert a `:maybe` type to a boolean using `False` for `Nothing` and `True` for `Just`.
public fun bool .1 : forall<a> (m : maybe<a>) -> bool
  = forall<a> fun(m:maybe<a>){
    match (m) {
      std/core/Nothing() -> std/core/False
      _ -> std/core/True
    }
  };
// Convert a string to a boolean, using `False` for the empty string and `True` otherwise.
public fun bool .2 : (s : string) -> bool
  = fun(s:string){
    std/core/(!=.3){@}(s, "")
  };
// Was this a cancelation exception?
public fun cancel? .1 : (exn : exception) -> bool
  = fun(exn:exception){
    match ((std/core/info{0,1,fast}(exn))) {
      std/core/Cancel() -> std/core/True
      _ -> std/core/False
    }
  };
// O(`n`). The first `n` (default = `1`) characters in a string.
public fun first : (s : string, n : ?int) -> sslice
  = fun(s:string, n:?int){
    val (.n) .13291 : int
      = match (n) {
        std/core/Optional(.n.13292) -> .n.13292
        _ -> 1
      };;
    val slice0 : sslice
      = std/core/first1{@}(s);;
    match ((std/core/(==.1){@}(.n.13291, 1))) {
      std/core/True() -> slice0
      std/core/False() -> std/core/extend{0,2,fast}(slice0, (std/core/(-){@}(.n.13291, 1)))
    }
  };
// Convert the first character of a string to uppercase.
public fun capitalize : (s : string) -> string
  = fun(s:string){
    std/core/(+.3){@}((std/core/to-upper{0,1,fast}((std/core/string.3{0,1,fast}((std/core/first{0,2,fast}(s, std/core/None)))))), (std/core/string.3{0,1,fast}((std/core/after{0,1,fast}((std/core/first{0,2,fast}(s, std/core/None)))))))
  };
// _Deprecated_; use `try` instead. Catch an exception raised by `throw` and handle it.
// Use `on-exn` or `on-exit` when appropiate.
public fun* (.bind-catch) : forall<a,e> (action : () -> <exn|e> a, hndl : (exception) -> e a) -> e a
  = forall<a,e> fun<e>(action:() -> <exn|e> a, hndl:(exception) -> e a){
    std/core/(.bind-try){2,2,bind}(action, hndl)
  };
// _Deprecated_; use `try` instead. Catch an exception raised by `throw` and handle it.
// Use `on-exn` or `on-exit` when appropiate.
public fun (.fast-catch) : forall<a,e> (action : () -> <exn|e> a, hndl : (exception) -> e a) -> e a
  = forall<a,e> fun<e>(action:() -> <exn|e> a, hndl:(exception) -> e a){
    std/core/(.fast-try){2,2,fast}(action, hndl)
  };
// _Deprecated_; use `try` instead. Catch an exception raised by `throw` and handle it.
// Use `on-exn` or `on-exit` when appropiate.
public fun** catch : forall<a,e> (action : () -> <exn|e> a, hndl : (exception) -> e a) -> e a
  = forall<a,e> fun<e>(action:() -> <exn|e> a, hndl:(exception) -> e a){
    std/core/(.bind-catch){2,2,bind}(action, hndl)
  };
public fun cdivmod-exp10 : (i : int, n : int) -> (int, int)
  = fun(i:int, n:int){
    match ((std/core/(<=.1){@}(n, 0))) {
      std/core/True() -> std/core/(,)(i, 0)
      std/core/False() -> val cq : int
                                = std/core/cdiv-exp10{0,2,fast}(i, n);
      std/core/(,)(cq, (std/core/(-){@}(i, (std/core/mul-exp10{0,2,fast}(cq, n)))))
    }
  };
// Return a random boolean
public fun random-bool : () -> ndet bool
  = fun<ndet>(){
    std/core/(>=.2){@}((std/core/random{0,0,fast}()), 0.5)
  };
// Returns one of its arguments `x`  or `y`  based on a non-deterministic choice.
public fun choose : forall<a> (x : a, y : a) -> ndet a
  = forall<a> fun<ndet>(x:a, y:a){
    match ((std/core/random-bool{0,0,fast}())) {
      std/core/True() -> x
      std/core/False() -> y
    }
  };
// Concatenate all lists in a list (e.g. flatten the list). (tail-recursive)
public fun concat : forall<a> (xs : list<list<a>>) -> list<a>
  = forall<a> fun(xs:list<list<a>>){
    fun** concat-rev : forall<b> (xss : list<list<b>>, acc : list<b>) -> list<b>
      = forall<b> fun(xss:list<list<b>>, acc:list<b>){
        match (xss) {
          std/core/Cons(ys, yss) -> concat-rev{1,2,fast}(yss, (std/core/(+.4){1,2,fast}(ys, acc)))
          std/core/Nil() -> acc
        }
      };;
    concat-rev{1,2,fast}((std/core/reverse{1,1,fast}(xs)), std/core/Nil)
  };
// Concatenate a list of `:maybe` values
public fun concat-maybe : forall<a> (xs : list<maybe<a>>) -> list<a>
  = forall<a> fun(xs:list<maybe<a>>){
    std/core/concat{1,1,fast}((std/core/map.5{3,2,poly}(xs, std/core/list.3{1,1,fast})))
  };
// Is the character an ASCII control character, e.g. `c < ' '`  ?
public fun control? : (c : char) -> bool
  = fun(c:char){
    std/core/(<){@}(c, ' ')
  };
// Executes `action`  for each integer between `start`  upto `end`  (including both `start`  and `end` ).
// If `start > end`  the function returns without any call to `action` .
// If `action` returns `Just`, the iteration is stopped and the result returned
fun* (.bind-for-while32) : forall<a,e> (start : int32, end : int32, action : (int32) -> e maybe<a>) -> e maybe<a>
  = forall<a,e> fun<e>(start0:int32, end:int32, action:(int32) -> e maybe<a>){
    val rep : (i : int32) -> e maybe<a>
      = fun<e>(i:int32){
        match ((std/core/(<=.2){@}(i, end))) {
          std/core/True() -> std/core/bind{@}((action(i)), (fun<e>(.y.167:maybe<a>){
              match (.y.167) {
                std/core/Nothing() -> rep((std/core/unsafe-decreasing{@}((std/core/incr{0,1,fast}(i)))))
                std/core/Just(x) -> std/core/Just(x)
              }
            }))
          std/core/False() -> std/core/Nothing
        }
      };;
    ;
    rep(start0)
  };
// Executes `action`  for each integer between `start`  upto `end`  (including both `start`  and `end` ).
// If `start > end`  the function returns without any call to `action` .
// If `action` returns `Just`, the iteration is stopped and the result returned
fun (.fast-for-while32) : forall<a,e> (start : int32, end : int32, action : (int32) -> e maybe<a>) -> e maybe<a>
  = forall<a,e> fun<e>(start0:int32, end:int32, action:(int32) -> e maybe<a>){
    val rep : (i : int32) -> e maybe<a>
      = fun<e>(i:int32){
        match ((std/core/(<=.2){@}(i, end))) {
          std/core/True() -> match ((action(i))) {
            std/core/Nothing() -> rep((std/core/unsafe-decreasing{@}((std/core/incr{0,1,fast}(i)))))
            std/core/Just(x) -> std/core/Just(x)
          }
          std/core/False() -> std/core/Nothing
        }
      };;
    ;
    rep(start0)
  };
// Executes `action`  for each integer between `start`  upto `end`  (including both `start`  and `end` ).
// If `start > end`  the function returns without any call to `action` .
// If `action` returns `Just`, the iteration is stopped and the result returned
fun** for-while32 : forall<a,e> (start : int32, end : int32, action : (int32) -> e maybe<a>) -> e maybe<a>
  = forall<a,e> fun<e>(start0:int32, end:int32, action:(int32) -> e maybe<a>){
    std/core/(.bind-for-while32){2,3,bind}(start0, end, action)
  };
// O(1). The entire string as a slice
public fun slice : (s : string) -> sslice
  = fun(s:string){
    std/core/Sslice(s, (std/core/int32{@}(0)), (std/core/length{@}(s)))
  };
// Invoke `action` for each element of a list while `action` return `Nothing`
public fun* (.bind-foreach-while) : forall<a,b,e> (xs : list<a>, action : (a) -> e maybe<b>) -> e maybe<b>
  = forall<a,b,e> fun<e>(xs:list<a>, action:(a) -> e maybe<b>){
    match (xs) {
      std/core/Nil() -> std/core/Nothing
      std/core/Cons(x, xx) -> std/core/bind{@}((action(x)), (fun<e>(.y.175:maybe<b>){
          match (.y.175) {
            std/core/Nothing() -> std/core/(.bind-foreach-while){3,2,bind}(xx, action)
            just -> just
          }
        }))
    }
  };
// Invoke `action` for each element of a list while `action` return `Nothing`
public fun (.fast-foreach-while) : forall<a,b,e> (xs : list<a>, action : (a) -> e maybe<b>) -> e maybe<b>
  = forall<a,b,e> fun<e>(xs0:list<a>, action0:(a) -> e maybe<b>){
    match (xs0) {
      std/core/Nil() -> std/core/Nothing
      std/core/Cons(x0, xx0) -> match ((action0(x0))) {
        std/core/Nothing() -> std/core/(.fast-foreach-while){3,2,fast}(xx0, action0)
        just0 -> just0
      }
    }
  };
// Invoke `action` for each element of a list while `action` return `Nothing`
public fun** foreach-while : forall<a,b,e> (xs : list<a>, action : (a) -> e maybe<b>) -> e maybe<b>
  = forall<a,b,e> fun<e>(xs1:list<a>, action1:(a) -> e maybe<b>){
    std/core/(.bind-foreach-while){3,2,bind}(xs1, action1)
  };
// Apply a function for each character in a string slice.
// If `action` returns `Just`, the function returns immediately with that result.
public fun* (.bind-foreach-while) .1 : forall<a,e> (slice : sslice, action : (c : char) -> e maybe<a>) -> e maybe<a>
  = forall<a,e> fun<e>(slice0:sslice, action:(c : char) -> e maybe<a>){
    match ((std/core/next{0,1,fast}(slice0))) {
      std/core/Nothing() -> std/core/Nothing
      std/core/Just(std/core/(,)(c, rest)) -> std/core/bind{@}((action(c)), (fun<e>(.y.180:maybe<a>){
          match (.y.180) {
            std/core/Nothing() -> std/core/(.bind-foreach-while.1){2,2,bind}((std/core/unsafe-decreasing{@}(rest)), action)
            res -> res
          }
        }))
    }
  };
// Apply a function for each character in a string slice.
// If `action` returns `Just`, the function returns immediately with that result.
public fun (.fast-foreach-while) .1 : forall<a,e> (slice : sslice, action : (c : char) -> e maybe<a>) -> e maybe<a>
  = forall<a,e> fun<e>(slice1:sslice, action0:(c : char) -> e maybe<a>){
    match ((std/core/next{0,1,fast}(slice1))) {
      std/core/Nothing() -> std/core/Nothing
      std/core/Just(std/core/(,)(c0, rest0)) -> match ((action0(c0))) {
        std/core/Nothing() -> std/core/(.fast-foreach-while.1){2,2,fast}((std/core/unsafe-decreasing{@}(rest0)), action0)
        res0 -> res0
      }
    }
  };
// Apply a function for each character in a string slice.
// If `action` returns `Just`, the function returns immediately with that result.
public fun** foreach-while .1 : forall<a,e> (slice : sslice, action : (c : char) -> e maybe<a>) -> e maybe<a>
  = forall<a,e> fun<e>(slice2:sslice, action1:(c : char) -> e maybe<a>){
    std/core/(.bind-foreach-while.1){2,2,bind}(slice2, action1)
  };
// Invoke a function for each character in a string.
// If `action` returns `Just`, the function returns immediately with that result.
public fun* (.bind-foreach-while) .2 : forall<a,e> (s : string, action : (c : char) -> e maybe<a>) -> e maybe<a>
  = forall<a,e> fun<e>(s:string, action:(c : char) -> e maybe<a>){
    std/core/(.bind-foreach-while.1){2,2,bind}((std/core/slice{0,1,fast}(s)), action)
  };
// Invoke a function for each character in a string.
// If `action` returns `Just`, the function returns immediately with that result.
public fun (.fast-foreach-while) .2 : forall<a,e> (s : string, action : (c : char) -> e maybe<a>) -> e maybe<a>
  = forall<a,e> fun<e>(s:string, action:(c : char) -> e maybe<a>){
    std/core/(.fast-foreach-while.1){2,2,fast}((std/core/slice{0,1,fast}(s)), action)
  };
// Invoke a function for each character in a string.
// If `action` returns `Just`, the function returns immediately with that result.
public fun** foreach-while .2 : forall<a,e> (s : string, action : (c : char) -> e maybe<a>) -> e maybe<a>
  = forall<a,e> fun<e>(s:string, action:(c : char) -> e maybe<a>){
    std/core/(.bind-foreach-while.2){2,2,bind}(s, action)
  };
// Invoke a function `f` for each element in a vector `v`.
// If `f` returns `Just`, the iteration is stopped early and the result is returned.
public fun* (.bind-foreach-while) .3 : forall<a,b,e> (v : vector<a>, f : (a) -> e maybe<b>) -> e maybe<b>
  = forall<a,b,e> fun<e>(v:vector<a>, f:(a) -> e maybe<b>){
    std/core/(.bind-for-while32){2,3,bind}((std/core/int32{@}(0)), (std/core/decr{0,1,fast}((std/core/length32{@}(v)))), (fun<e>(i:int32){
        (f((std/core/unsafe-idx{@}(v, i))))
      }))
  };
// Invoke a function `f` for each element in a vector `v`.
// If `f` returns `Just`, the iteration is stopped early and the result is returned.
public fun (.fast-foreach-while) .3 : forall<a,b,e> (v : vector<a>, f : (a) -> e maybe<b>) -> e maybe<b>
  = forall<a,b,e> fun<e>(v:vector<a>, f:(a) -> e maybe<b>){
    std/core/(.fast-for-while32){2,3,fast}((std/core/int32{@}(0)), (std/core/decr{0,1,fast}((std/core/length32{@}(v)))), (fun<e>(i:int32){
        (f((std/core/unsafe-idx{@}(v, i))))
      }))
  };
// Invoke a function `f` for each element in a vector `v`.
// If `f` returns `Just`, the iteration is stopped early and the result is returned.
public fun** foreach-while .3 : forall<a,b,e> (v : vector<a>, f : (a) -> e maybe<b>) -> e maybe<b>
  = forall<a,b,e> fun<e>(v:vector<a>, f:(a) -> e maybe<b>){
    std/core/(.bind-foreach-while.3){3,2,bind}(v, f)
  };
// Invoke `action` for each element of a list
public fun* (.bind-foreach) : forall<a,e> (xs : list<a>, action : (a) -> e ()) -> e ()
  = forall<a,e> fun<e>(xs:list<a>, action:(a) -> e ()){
    match (xs) {
      std/core/Nil() -> std/core/()
      std/core/Cons(x, xx) -> std/core/bind{@}((action(x)), (fun<e>(_:()){
          (std/core/(.bind-foreach){2,2,bind}(xx, action))
        }))
    }
  };
// Invoke `action` for each element of a list
public fun (.fast-foreach) : forall<a,e> (xs : list<a>, action : (a) -> e ()) -> e ()
  = forall<a,e> fun<e>(xs0:list<a>, action0:(a) -> e ()){
    match (xs0) {
      std/core/Nil() -> std/core/()
      std/core/Cons(x0, xx0) -> val _0 : ()
                                      = action0(x0);
      std/core/(.fast-foreach){2,2,fast}(xx0, action0)
    }
  };
// Invoke `action` for each element of a list
public fun** foreach : forall<a,e> (xs : list<a>, action : (a) -> e ()) -> e ()
  = forall<a,e> fun<e>(xs1:list<a>, action1:(a) -> e ()){
    std/core/(.bind-foreach){2,2,bind}(xs1, action1)
  };
// Apply a function for each character in a string slice.
public fun* (.bind-foreach) .1 : forall<e> (slice : sslice, action : (c : char) -> e ()) -> e ()
  = forall<e> fun<e>(slice0:sslice, action:(c : char) -> e ()){
    std/core/bind{@}((std/core/(.bind-foreach-while.1){2,2,bind}(slice0, (fun<e>(c:char){
          (std/core/bind{@}((action(c)), (fun<e>(_:()){
              std/core/Nothing
            })))
        }))), (fun<e>(_0:maybe<void>){
        std/core/()
      }))
  };
// Apply a function for each character in a string slice.
public fun (.fast-foreach) .1 : forall<e> (slice : sslice, action : (c : char) -> e ()) -> e ()
  = forall<e> fun<e>(slice0:sslice, action:(c : char) -> e ()){
    val _0 : maybe<void>
          = std/core/(.fast-foreach-while.1){2,2,fast}(slice0, (fun<e>(c:char){
              val _ : ()
                    = (action(c));
              std/core/Nothing
            }));
    std/core/()
  };
// Apply a function for each character in a string slice.
public fun** foreach .1 : forall<e> (slice : sslice, action : (c : char) -> e ()) -> e ()
  = forall<e> fun<e>(slice0:sslice, action:(c : char) -> e ()){
    std/core/(.bind-foreach.1){1,2,bind}(slice0, action)
  };
// Invoke a function for each character in a string
public fun* (.bind-foreach) .2 : forall<e> (s : string, action : (c : char) -> e ()) -> e ()
  = forall<e> fun<e>(s:string, action:(c : char) -> e ()){
    std/core/(.bind-foreach.1){1,2,bind}((std/core/slice{0,1,fast}(s)), action)
  };
// Invoke a function for each character in a string
public fun (.fast-foreach) .2 : forall<e> (s : string, action : (c : char) -> e ()) -> e ()
  = forall<e> fun<e>(s:string, action:(c : char) -> e ()){
    std/core/(.fast-foreach.1){1,2,fast}((std/core/slice{0,1,fast}(s)), action)
  };
// Invoke a function for each character in a string
public fun** foreach .2 : forall<e> (s : string, action : (c : char) -> e ()) -> e ()
  = forall<e> fun<e>(s:string, action:(c : char) -> e ()){
    std/core/(.bind-foreach.2){1,2,bind}(s, action)
  };
// Invoke a function `f` for each element in a vector `v`
public fun* (.bind-foreach) .3 : forall<a,e> (v : vector<a>, f : (a) -> e ()) -> e ()
  = forall<a,e> fun<e>(v:vector<a>, f:(a) -> e ()){
    std/core/(.bind-foreach-indexed32){2,2,bind}(v, (fun<e>(x:a, _(2339,30):int32){
        (f(x))
      }))
  };
// Invoke a function `f` for each element in a vector `v`
public fun (.fast-foreach) .3 : forall<a,e> (v : vector<a>, f : (a) -> e ()) -> e ()
  = forall<a,e> fun<e>(v:vector<a>, f:(a) -> e ()){
    std/core/(.fast-foreach-indexed32){2,2,fast}(v, (fun<e>(x:a, _(2339,30):int32){
        (f(x))
      }))
  };
// Invoke a function `f` for each element in a vector `v`
public fun** foreach .3 : forall<a,e> (v : vector<a>, f : (a) -> e ()) -> e ()
  = forall<a,e> fun<e>(v:vector<a>, f:(a) -> e ()){
    std/core/(.bind-foreach.3){2,2,bind}(v, f)
  };
// O(n). Return the number of characters in a string.
public fun count .1 : (s : string) -> int
  = fun(s:string){
    std/core/(.extern-count){@}(s)
  };
// O(n). Return the number of characters in a string slice
public fun count .2 : (slice : sslice) -> int
  = fun(slice0:sslice){
    std/core/(.extern-count.1){@}(slice0)
  };
// Count the number of times a predicate is true for each character in a string
public fun count .3 : (s : string, pred : (char) -> bool) -> int
  = fun(s:string, pred:(char) -> bool){
    var cnt : ref<void,int>
      = std/core/ref{@}(0);;
    val _ : ()
      = std/core/foreach.2{1,2,poly}(s, (fun<<read<void>,write<void>,alloc<void>>>(c:char){
          match ((pred(c))) {
            std/core/True() -> std/core/set{@}(cnt, (std/core/(+){@}((std/core/(!.1){@}(cnt)), 1)))
            std/core/False() -> std/core/()
          }
        }));;
    std/core/(!.1){@}(cnt)
  };
// Create a new `:delayed` value.
public fun delay : forall<a,e> (action : () -> e a) -> delayed<e,a>
  = forall<a,e> fun(action:() -> e a){
    std/core/unsafe-total{2,1,fast}((fun<(alloc<global>)>(){
      (std/core/Delay((std/core/ref{@}((std/core/Left(action))))))
    }))
  };
// Calculate `10^exp`
public fun exp10 : (exp : int) -> int
  = fun(exp:int){
    std/core/mul-exp10{0,2,fast}(1, exp)
  };
// Is the integer negative (stricly smaller than zero)
public fun neg? .1 : (i : int) -> bool
  = fun(i:int){
    std/core/(==.4){0,2,fast}((std/core/sign{@}(i)), std/core/Lt)
  };
// Is the value negative?
public fun neg? .2 : (d : double) -> bool
  = fun(d:double){
    std/core/(<.3){@}(d, 0.0)
  };
public fun divmod-exp10 : (i : int, n : int) -> (int, int)
  = fun(i:int, n:int){
    match ((std/core/cdivmod-exp10{0,2,fast}(i, n))) {
      std/core/(,)(cq, cr) -> match ((std/core/(!){@}((std/core/neg?.1{0,1,fast}(cr))))) {
        std/core/True() -> std/core/(,)(cq, cr)
        std/core/False() -> std/core/(,)((std/core/dec{0,1,fast}(cq)), (std/core/(+){@}(cr, (std/core/exp10{0,1,fast}(n)))))
      }
    }
  };
// Drop the first `n` elements of a list (or fewer if the list is shorter than `n`)
public fun drop : forall<a> (xs : list<a>, n : int) -> list<a>
  = forall<a> fun(xs:list<a>, n:int){
    match ((std/core/(<=.1){@}(n, 0))) {
      std/core/True() -> xs
      std/core/False() -> match (xs) {
        std/core/Nil() -> std/core/Nil
        std/core/Cons(_, xx) -> std/core/drop{1,2,fast}(xx, (std/core/(-){@}(n, 1)))
      }
    }
  };
public fun* (.bind-span) : forall<a,e> (xs : list<a>, predicate : (a) -> e bool) -> e (list<a>, list<a>)
  = forall<a,e> fun<e>(xs:list<a>, predicate:(a) -> e bool){
    val span-acc : (list<a>, list<a>) -> e (list<a>, list<a>)
      = fun<e>(ys:list<a>, acc:list<a>){
        match (ys) {
          std/core/Cons(y, yy) -> std/core/bind{@}((predicate(y)), (fun<e>(.y.203:bool){
              match (.y.203) {
                std/core/True() -> span-acc(yy, (std/core/Cons(y, acc)))
                std/core/False() -> std/core/(,)((std/core/reverse{1,1,fast}(acc)), ys)
              }
            }))
          _ -> std/core/(,)((std/core/reverse{1,1,fast}(acc)), ys)
        }
      };;
    ;
    span-acc(xs, std/core/Nil)
  };
public fun (.fast-span) : forall<a,e> (xs : list<a>, predicate : (a) -> e bool) -> e (list<a>, list<a>)
  = forall<a,e> fun<e>(xs:list<a>, predicate:(a) -> e bool){
    val span-acc : (list<a>, list<a>) -> e (list<a>, list<a>)
      = fun<e>(ys:list<a>, acc:list<a>){
        match (ys) {
          std/core/Cons(y, yy) -> match ((predicate(y))) {
            std/core/True() -> span-acc(yy, (std/core/Cons(y, acc)))
            std/core/False() -> std/core/(,)((std/core/reverse{1,1,fast}(acc)), ys)
          }
          _ -> std/core/(,)((std/core/reverse{1,1,fast}(acc)), ys)
        }
      };;
    ;
    span-acc(xs, std/core/Nil)
  };
public fun** span : forall<a,e> (xs : list<a>, predicate : (a) -> e bool) -> e (list<a>, list<a>)
  = forall<a,e> fun<e>(xs:list<a>, predicate:(a) -> e bool){
    std/core/(.bind-span){2,2,bind}(xs, predicate)
  };
// Drop all initial elements that satisfy `predicate`
public fun* (.bind-drop-while) : forall<a,e> (xs : list<a>, predicate : (a) -> e bool) -> e list<a>
  = forall<a,e> fun<e>(xs:list<a>, predicate:(a) -> e bool){
    std/core/bind{@}((std/core/(.bind-span){2,2,bind}(xs, predicate)), (fun<e>(.y.213:(list<a>, list<a>)){
        (std/core/snd{2,1,fast}(.y.213))
      }))
  };
// Drop all initial elements that satisfy `predicate`
public fun (.fast-drop-while) : forall<a,e> (xs : list<a>, predicate : (a) -> e bool) -> e list<a>
  = forall<a,e> fun<e>(xs:list<a>, predicate:(a) -> e bool){
    std/core/snd{2,1,fast}((std/core/(.fast-span){2,2,fast}(xs, predicate)))
  };
// Drop all initial elements that satisfy `predicate`
public fun** drop-while : forall<a,e> (xs : list<a>, predicate : (a) -> e bool) -> e list<a>
  = forall<a,e> fun<e>(xs:list<a>, predicate:(a) -> e bool){
    std/core/(.bind-drop-while){2,2,bind}(xs, predicate)
  };
// Does string `s`  end with `post`?
// If so, returns a slice of `s` from the start up to the `post` string at the end.
public fun ends-with : (s : string, post : string) -> maybe<sslice>
  = fun(s:string, post:string){
    match ((std/core/xends-with{0,2,fast}(s, post))) {
      std/core/True() -> std/core/Just((std/core/Sslice(s, (std/core/int32{@}(0)), (std/core/(-.1){@}((std/core/length{@}(s)), (std/core/length{@}(post)))))))
      std/core/False() -> std/core/Nothing
    }
  };
// Calculate `2^exp`.
public fun exp2 : (exp : int) -> int
  = fun(exp:int){
    std/core/pow{0,2,fast}(2, exp)
  };
// Retain only those elements of a list that satisfy the given predicate `pred`.
// For example: `filter([1,2,3],odd?) == [1,3]`
public fun* (.bind-filter) : forall<a,e> (xs : list<a>, pred : (a) -> e bool) -> e list<a>
  = forall<a,e> fun<e>(xs:list<a>, pred:(a) -> e bool){
    match (xs) {
      std/core/Nil() -> std/core/Nil
      std/core/Cons(x, xx) -> std/core/bind{@}((pred(x)), (fun<e>(.y.215:bool){
          match (.y.215) {
            std/core/True() -> std/core/bind{@}((std/core/(.bind-filter){2,2,bind}(xx, pred)), (fun<e>(.y.216:list<a>){
                (std/core/Cons(x, .y.216))
              }))
            std/core/False() -> std/core/(.bind-filter){2,2,bind}(xx, pred)
          }
        }))
    }
  };
// Retain only those elements of a list that satisfy the given predicate `pred`.
// For example: `filter([1,2,3],odd?) == [1,3]`
public fun (.fast-filter) : forall<a,e> (xs : list<a>, pred : (a) -> e bool) -> e list<a>
  = forall<a,e> fun<e>(xs0:list<a>, pred0:(a) -> e bool){
    match (xs0) {
      std/core/Nil() -> std/core/Nil
      std/core/Cons(x0, xx0) -> match ((pred0(x0))) {
        std/core/True() -> std/core/Cons(x0, (std/core/(.fast-filter){2,2,fast}(xx0, pred0)))
        std/core/False() -> std/core/(.fast-filter){2,2,fast}(xx0, pred0)
      }
    }
  };
// Retain only those elements of a list that satisfy the given predicate `pred`.
// For example: `filter([1,2,3],odd?) == [1,3]`
public fun** filter : forall<a,e> (xs : list<a>, pred : (a) -> e bool) -> e list<a>
  = forall<a,e> fun<e>(xs1:list<a>, pred1:(a) -> e bool){
    std/core/(.bind-filter){2,2,bind}(xs1, pred1)
  };
// Retain only those elements of a list that satisfy the given predicate `pred`.
// For example: `filterMap([1,2,3],fun(i) { if (i.odd?) then Nothing else Just(i*i) }) == [4]`
public fun* (.bind-filter-map) : forall<a,b,e> (xs : list<a>, pred : (a) -> e maybe<b>) -> e list<b>
  = forall<a,b,e> fun<e>(xs:list<a>, pred:(a) -> e maybe<b>){
    match (xs) {
      std/core/Nil() -> std/core/Nil
      std/core/Cons(x, xx) -> std/core/bind{@}((pred(x)), (fun<e>(.y.221:maybe<b>){
          match (.y.221) {
            std/core/Nothing() -> std/core/(.bind-filter-map){3,2,bind}(xx, pred)
            std/core/Just(y) -> std/core/bind{@}((std/core/(.bind-filter-map){3,2,bind}(xx, pred)), (fun<e>(.y.223:list<b>){
                (std/core/Cons(y, .y.223))
              }))
          }
        }))
    }
  };
// Retain only those elements of a list that satisfy the given predicate `pred`.
// For example: `filterMap([1,2,3],fun(i) { if (i.odd?) then Nothing else Just(i*i) }) == [4]`
public fun (.fast-filter-map) : forall<a,b,e> (xs : list<a>, pred : (a) -> e maybe<b>) -> e list<b>
  = forall<a,b,e> fun<e>(xs0:list<a>, pred0:(a) -> e maybe<b>){
    match (xs0) {
      std/core/Nil() -> std/core/Nil
      std/core/Cons(x0, xx0) -> match ((pred0(x0))) {
        std/core/Nothing() -> std/core/(.fast-filter-map){3,2,fast}(xx0, pred0)
        std/core/Just(y0) -> std/core/Cons(y0, (std/core/(.fast-filter-map){3,2,fast}(xx0, pred0)))
      }
    }
  };
// Retain only those elements of a list that satisfy the given predicate `pred`.
// For example: `filterMap([1,2,3],fun(i) { if (i.odd?) then Nothing else Just(i*i) }) == [4]`
public fun** filter-map : forall<a,b,e> (xs : list<a>, pred : (a) -> e maybe<b>) -> e list<b>
  = forall<a,b,e> fun<e>(xs1:list<a>, pred1:(a) -> e maybe<b>){
    std/core/(.bind-filter-map){3,2,bind}(xs1, pred1)
  };
// Was this a finalization exception?
public fun finalize? .1 : (exn : exception) -> bool
  = fun(exn:exception){
    match ((std/core/info{0,1,fast}(exn))) {
      std/core/Finalize() -> std/core/True
      _ -> std/core/False
    }
  };
// Find the first element satisfying some predicate
public fun find : forall<a> (xs : list<a>, pred : (a) -> bool) -> maybe<a>
  = forall<a> fun(xs:list<a>, pred:(a) -> bool){
    std/core/foreach-while{3,2,poly}(xs, (fun(x:a){
        match ((pred(x))) {
          std/core/True() -> std/core/Just(x)
          std/core/False() -> std/core/Nothing
        }
      }))
  };
// O(n). If it occurs, return the position of substring `sub` in `s`, tupled with
// the position just following the substring `sub`.
public fun find .1 : (s : string, sub : string) -> maybe<sslice>
  = fun(s:string, sub:string){
    val i : int32
          = std/core/xindex-of{@}(s, sub);
    match ((std/core/neg?{@}(i))) {
      std/core/True() -> std/core/Nothing
      std/core/False() -> std/core/Just((std/core/Sslice(s, i, (std/core/length{@}(sub)))))
    }
  };
// Return the last index of substring `sub` in `s` if it occurs.
public fun find-last : (s : string, sub : string) -> maybe<sslice>
  = fun(s:string, sub:string){
    val i : int32
          = std/core/xlast-index-of{@}(s, sub);
    match ((std/core/neg?{@}(i))) {
      std/core/True() -> std/core/Nothing
      std/core/False() -> std/core/Just((std/core/Sslice(s, i, (std/core/length{@}(sub)))))
    }
  };
// Find the first element satisfying some predicate and return it.
public fun find-maybe : forall<a,b> (xs : list<a>, pred : (a) -> maybe<b>) -> maybe<b>
  = forall<a,b> fun(xs:list<a>, pred:(a) -> maybe<b>){
    std/core/foreach-while{3,2,poly}(xs, pred)
  };
// Concatenate the result lists from applying a function to all elements.
public fun* (.bind-flatmap) : forall<a,b,e> (xs : list<a>, f : (a) -> e list<b>) -> e list<b>
  = forall<a,b,e> fun<e>(xs:list<a>, f:(a) -> e list<b>){
    std/core/bind{@}((std/core/(.bind-map.5){3,2,bind}(xs, f)), (fun<e>(.y.227:list<list<b>>){
        (std/core/concat{1,1,fast}(.y.227))
      }))
  };
// Concatenate the result lists from applying a function to all elements.
public fun (.fast-flatmap) : forall<a,b,e> (xs : list<a>, f : (a) -> e list<b>) -> e list<b>
  = forall<a,b,e> fun<e>(xs:list<a>, f:(a) -> e list<b>){
    std/core/concat{1,1,fast}((std/core/(.fast-map.5){3,2,fast}(xs, f)))
  };
// Concatenate the result lists from applying a function to all elements.
public fun** flatmap : forall<a,b,e> (xs : list<a>, f : (a) -> e list<b>) -> e list<b>
  = forall<a,b,e> fun<e>(xs:list<a>, f:(a) -> e list<b>){
    std/core/(.bind-flatmap){3,2,bind}(xs, f)
  };
public fun* (.bind-foldl1) : forall<a,e> (xs : list<a>, f : (a, a) -> <exn|e> a) -> <exn|e> a
  = forall<a,e> fun<<exn|e>>(xs:list<a>, f:(a, a) -> <exn|e> a){
    match (xs) {
      std/core/Cons(x, xx) -> std/core/(.bind-foldl){3,3,bind}(xx, x, f)
      _ -> std/core/error-pattern{1,2,fast}("lib/std/core.kk(919, 3)", "foldl1")
    }
  };
public fun (.fast-foldl1) : forall<a,e> (xs : list<a>, f : (a, a) -> <exn|e> a) -> <exn|e> a
  = forall<a,e> fun<<exn|e>>(xs:list<a>, f:(a, a) -> <exn|e> a){
    match (xs) {
      std/core/Cons(x, xx) -> std/core/(.fast-foldl){3,3,fast}(xx, x, f)
      _ -> std/core/error-pattern{1,2,fast}("lib/std/core.kk(919, 3)", "foldl1")
    }
  };
public fun** foldl1 : forall<a,e> (xs : list<a>, f : (a, a) -> <exn|e> a) -> <exn|e> a
  = forall<a,e> fun<<exn|e>>(xs:list<a>, f:(a, a) -> <exn|e> a){
    std/core/(.bind-foldl1){2,2,bind}(xs, f)
  };
// Fold a list from the right, i.e. `foldr([1,2],0,(+)) == 1+(2+0)`
// Note, `foldr` is less efficient than `foldl` as it reverses the list first.
public fun* (.bind-foldr) : forall<a,b,e> (xs : list<a>, z : b, f : (a, b) -> e b) -> e b
  = forall<a,b,e> fun<e>(xs:list<a>, z:b, f:(a, b) -> e b){
    std/core/(.bind-foldl){3,3,bind}((std/core/reverse{1,1,fast}(xs)), z, (fun<e>(x:b, y:a){
        (f(y, x))
      }))
  };
// Fold a list from the right, i.e. `foldr([1,2],0,(+)) == 1+(2+0)`
// Note, `foldr` is less efficient than `foldl` as it reverses the list first.
public fun (.fast-foldr) : forall<a,b,e> (xs : list<a>, z : b, f : (a, b) -> e b) -> e b
  = forall<a,b,e> fun<e>(xs:list<a>, z:b, f:(a, b) -> e b){
    std/core/(.fast-foldl){3,3,fast}((std/core/reverse{1,1,fast}(xs)), z, (fun<e>(x:b, y:a){
        (f(y, x))
      }))
  };
// Fold a list from the right, i.e. `foldr([1,2],0,(+)) == 1+(2+0)`
// Note, `foldr` is less efficient than `foldl` as it reverses the list first.
public fun** foldr : forall<a,b,e> (xs : list<a>, z : b, f : (a, b) -> e b) -> e b
  = forall<a,b,e> fun<e>(xs:list<a>, z:b, f:(a, b) -> e b){
    std/core/(.bind-foldr){3,3,bind}(xs, z, f)
  };
public fun* (.bind-foldr1) : forall<a,e> (xs : list<a>, f : (a, a) -> <exn|e> a) -> <exn|e> a
  = forall<a,e> fun<<exn|e>>(xs:list<a>, f:(a, a) -> <exn|e> a){
    match (xs) {
      std/core/Cons(x, std/core/Nil()) -> x
      std/core/Cons(x0, xx) -> std/core/bind{@}((std/core/(.bind-foldr1){2,2,bind}(xx, f)), (fun<<exn|e>>(.y.234:a){
          (f(x0, .y.234))
        }))
      _ -> std/core/error-pattern{1,2,fast}("lib/std/core.kk(926, 3)", "foldr1")
    }
  };
public fun (.fast-foldr1) : forall<a,e> (xs : list<a>, f : (a, a) -> <exn|e> a) -> <exn|e> a
  = forall<a,e> fun<<exn|e>>(xs0:list<a>, f0:(a, a) -> <exn|e> a){
    match (xs0) {
      std/core/Cons(x1, std/core/Nil()) -> x1
      std/core/Cons(x2, xx0) -> f0(x2, (std/core/(.fast-foldr1){2,2,fast}(xx0, f0)))
      _ -> std/core/error-pattern{1,2,fast}("lib/std/core.kk(926, 3)", "foldr1")
    }
  };
public fun** foldr1 : forall<a,e> (xs : list<a>, f : (a, a) -> <exn|e> a) -> <exn|e> a
  = forall<a,e> fun<<exn|e>>(xs1:list<a>, f1:(a, a) -> <exn|e> a){
    std/core/(.bind-foldr1){2,2,bind}(xs1, f1)
  };
// Executes `action`  for each integer between `start`  upto `end`  (including both `start`  and `end` ).
// If `start > end`  the function returns without any call to `action` .
// If `action` returns `Just`, the iteration is stopped and the result returned
public fun* (.bind-for-while) : forall<a,e> (start : int, end : int, action : (int) -> e maybe<a>) -> e maybe<a>
  = forall<a,e> fun<e>(start0:int, end:int, action:(int) -> e maybe<a>){
    val rep : (i : int) -> e maybe<a>
      = fun<e>(i:int){
        match ((std/core/(<=.1){@}(i, end))) {
          std/core/True() -> std/core/bind{@}((action(i)), (fun<e>(.y.240:maybe<a>){
              match (.y.240) {
                std/core/Nothing() -> rep((std/core/unsafe-decreasing{@}((std/core/inc{0,1,fast}(i)))))
                std/core/Just(x) -> std/core/Just(x)
              }
            }))
          std/core/False() -> std/core/Nothing
        }
      };;
    ;
    rep(start0)
  };
// Executes `action`  for each integer between `start`  upto `end`  (including both `start`  and `end` ).
// If `start > end`  the function returns without any call to `action` .
// If `action` returns `Just`, the iteration is stopped and the result returned
public fun (.fast-for-while) : forall<a,e> (start : int, end : int, action : (int) -> e maybe<a>) -> e maybe<a>
  = forall<a,e> fun<e>(start0:int, end:int, action:(int) -> e maybe<a>){
    val rep : (i : int) -> e maybe<a>
      = fun<e>(i:int){
        match ((std/core/(<=.1){@}(i, end))) {
          std/core/True() -> match ((action(i))) {
            std/core/Nothing() -> rep((std/core/unsafe-decreasing{@}((std/core/inc{0,1,fast}(i)))))
            std/core/Just(x) -> std/core/Just(x)
          }
          std/core/False() -> std/core/Nothing
        }
      };;
    ;
    rep(start0)
  };
// Executes `action`  for each integer between `start`  upto `end`  (including both `start`  and `end` ).
// If `start > end`  the function returns without any call to `action` .
// If `action` returns `Just`, the iteration is stopped and the result returned
public fun** for-while : forall<a,e> (start : int, end : int, action : (int) -> e maybe<a>) -> e maybe<a>
  = forall<a,e> fun<e>(start0:int, end:int, action:(int) -> e maybe<a>){
    std/core/(.bind-for-while){2,3,bind}(start0, end, action)
  };
// Force a delayed value; the value is computed only on the first
// call to `force` and cached afterwards.
public fun* (.bind-force) : forall<a,e> (delayed : delayed<e,a>) -> e a
  = forall<a,e> fun<e>(delayed:delayed<e,a>){
    std/core/unsafe-total{2,1,fast}((fun<<div,alloc<global>,read<global>,write<global>|e>>(){
      val r.26056 : (ref<global,either<() -> e a,a>>)
            = (std/core/dref{2,1,fast}(delayed));
      match ((std/core/(!.1){@}(r.26056))) {
        std/core/Right(x) -> x
        std/core/Left(action) -> std/core/bind{@}((std/core/inject-st.1{@}((std/core/inject-div{@}(action)))()), (fun<<st<global>,div|e>>(x0:a){
            val _.26060 : ()
                  = (std/core/set{@}(r.26056, (std/core/Right(x0))));
            x0
          }))
      }
    }))
  };
// Force a delayed value; the value is computed only on the first
// call to `force` and cached afterwards.
public fun (.fast-force) : forall<a,e> (delayed : delayed<e,a>) -> e a
  = forall<a,e> fun<e>(delayed:delayed<e,a>){
    std/core/unsafe-total{2,1,fast}((fun<<div,alloc<global>,read<global>,write<global>|e>>(){
      val r : (ref<global,either<() -> e a,a>>)
            = (std/core/dref{2,1,fast}(delayed));
      match ((std/core/(!.1){@}(r))) {
        std/core/Right(x) -> x
        std/core/Left(action) -> val x0 : a
                                   = std/core/inject-st.1{@}((std/core/inject-div{@}(action)))();;
                                 val _ : ()
                                   = std/core/set{@}(r, (std/core/Right(x0)));;
        x0
      }
    }))
  };
// Force a delayed value; the value is computed only on the first
// call to `force` and cached afterwards.
public fun** force : forall<a,e> (delayed : delayed<e,a>) -> e a
  = forall<a,e> fun<e>(delayed:delayed<e,a>){
    std/core/(.bind-force){2,1,bind}(delayed)
  };
// Invoke `action` for each element of a list, passing also the position of the element.
public fun* (.bind-foreach-indexed) : forall<a,e> (xs : list<a>, action : (int, a) -> e ()) -> e ()
  = forall<a,e> fun<e>(xs:list<a>, action:(int, a) -> e ()){
    val i : ref<void,int>
          = std/core/ref{@}(0);
    std/core/(.bind-foreach){2,2,bind}(xs, (fun<<alloc<void>,read<void>,write<void>|e>>(x:a){
        (std/core/bind{@}((std/core/inject-st.2{@}(action)((std/core/(!.1){@}(i)), x)), (fun<<st<void>|e>>(_:()){
            val .y.263.26062 : int
                  = (std/core/(+){@}((std/core/(!.1){@}(i)), 1));
            (std/core/set{@}(i, .y.263.26062))
          })))
      }))
  };
// Invoke `action` for each element of a list, passing also the position of the element.
public fun (.fast-foreach-indexed) : forall<a,e> (xs : list<a>, action : (int, a) -> e ()) -> e ()
  = forall<a,e> fun<e>(xs:list<a>, action:(int, a) -> e ()){
    val i : ref<void,int>
          = std/core/ref{@}(0);
    std/core/(.fast-foreach){2,2,fast}(xs, (fun<<alloc<void>,read<void>,write<void>|e>>(x:a){
        val _ : ()
              = (std/core/inject-st.2{@}(action)((std/core/(!.1){@}(i)), x));
        (std/core/set{@}(i, (std/core/(+){@}((std/core/(!.1){@}(i)), 1))))
      }))
  };
// Invoke `action` for each element of a list, passing also the position of the element.
public fun** foreach-indexed : forall<a,e> (xs : list<a>, action : (int, a) -> e ()) -> e ()
  = forall<a,e> fun<e>(xs:list<a>, action:(int, a) -> e ()){
    std/core/(.bind-foreach-indexed){2,2,bind}(xs, action)
  };
// Invoke a function `f` for each element in a vector `v`
public fun* (.bind-foreach-indexed) .1 : forall<a,e> (v : vector<a>, f : (a, int) -> e ()) -> e ()
  = forall<a,e> fun<e>(v:vector<a>, f:(a, int) -> e ()){
    std/core/(.bind-foreach-indexed32){2,2,bind}(v, (fun<e>(x:a, i:int32){
        (f(x, (std/core/int.1{@}(i))))
      }))
  };
// Invoke a function `f` for each element in a vector `v`
public fun (.fast-foreach-indexed) .1 : forall<a,e> (v : vector<a>, f : (a, int) -> e ()) -> e ()
  = forall<a,e> fun<e>(v:vector<a>, f:(a, int) -> e ()){
    std/core/(.fast-foreach-indexed32){2,2,fast}(v, (fun<e>(x:a, i:int32){
        (f(x, (std/core/int.1{@}(i))))
      }))
  };
// Invoke a function `f` for each element in a vector `v`
public fun** foreach-indexed .1 : forall<a,e> (v : vector<a>, f : (a, int) -> e ()) -> e ()
  = forall<a,e> fun<e>(v:vector<a>, f:(a, int) -> e ()){
    std/core/(.bind-foreach-indexed.1){2,2,bind}(v, f)
  };
val redirect : ref<global,maybe<(string) -> console ()>>
  = std/core/unsafe-total{2,1,fast}((fun<(alloc<global>)>(){
    (std/core/ref{@}(std/core/Nothing))
  }));
fun prints : (s : string) -> console ()
  = fun<console>(s:string){
    std/core/unsafe-total{2,1,fast}((fun<<console,read<global>>>(){
      match ((std/core/(!.1){@}(std/core/redirect))) {
        std/core/Nothing() -> std/core/xprints{0,1,fast}(s)
        std/core/Just(f) -> f(s)
      }
    }))
  };
// Concatenate all strings in a list
fun joinsep : (xs : list<string>, sep : string) -> string
  = fun(xs:list<string>, sep:string){
    val join-acc : (ys : list<string>, acc : string) -> string
      = fun(ys:list<string>, acc:string){
        match (ys) {
          std/core/Cons(y, yy) -> join-acc(yy, (std/core/(+.3){@}((std/core/(+.3){@}(acc, sep)), y)))
          std/core/Nil() -> acc
        }
      };;
    match (xs) {
      std/core/Nil() -> ""
      std/core/Cons(x, xx) -> join-acc(xx, x)
    }
  };
// Concatenate all strings in a list
public fun join .2 : (xs : list<string>) -> string
  = fun(xs:list<string>){
    std/core/joinsep{0,2,fast}(xs, "")
  };
// Concatenate all strings in a list using a specific separator
public fun join .3 : (xs : list<string>, sep : string) -> string
  = fun(xs:list<string>, sep:string){
    std/core/joinsep{0,2,fast}(xs, sep)
  };
// Right-align a string to width `width`  using `fill`  (default is a space) to fill from the left.
public fun pad-left : (s : string, width : int, fill : ?char) -> string
  = fun(s:string, width:int, fill:?char){
    val (.fill) .16830 : char
      = match (fill) {
        std/core/Optional(.fill.16831) -> .fill.16831
        _ -> ' '
      };;
    val w : int32
      = std/core/int32{@}(width);;
    val n : int32
      = std/core/length{@}(s);;
    match ((std/core/(<=.2){@}(w, n))) {
      std/core/True() -> s
      std/core/False() -> std/core/(+.3){@}((std/core/repeat32{0,2,fast}((std/core/string{0,1,fast}(.fill.16830)), (std/core/(-.1){@}(w, n)))), s)
    }
  };
// Show an `:int` as a hexadecimal value.\
// The `width`  parameter specifies how wide the hex value is where `"0"`  is used to align.\
// The `use-capitals` parameter (= `True`) determines if captical letters should be used to display the hexadecimal digits.\
// The `pre` (=`"0x"`) is an optional prefix for the number (goes between the sign and the number).
public fun show-hex : (i : int, width : ?int, use-capitals : ?bool, pre : ?string) -> string
  = fun(i:int, width:?int, use-capitals:?bool, pre:?string){
    val (.width) .16998 : int
      = match (width) {
        std/core/Optional(.width.16999) -> .width.16999
        _ -> 1
      };;
    val (.use-capitals) .17002 : bool
      = match (use-capitals) {
        std/core/Optional(.use-capitals.17003) -> .use-capitals.17003
        _ -> std/core/True
      };;
    val (.pre) .17006 : string
      = match (pre) {
        std/core/Optional(.pre.17007) -> .pre.17007
        _ -> "0x"
      };;
    std/core/(+.3){@}((std/core/(+.3){@}(match ((std/core/(<.1){@}(i, 0))) {
          std/core/True() -> "-"
          std/core/False() -> ""
        }, .pre.17006)), (std/core/pad-left{0,3,fast}((std/core/int-show-hex{0,2,fast}((std/core/abs{@}(i)), .use-capitals.17002)), .width.16998, (std/core/Optional('0')))))
  };
// Show a character as a string
fun show-char : (c : char) -> string
  = fun(c:char){
    match ((std/core/(||){@}((std/core/(<){@}(c, ' ')), (std/core/(>){@}(c, '~'))))) {
      std/core/True() -> match ((std/core/(==){@}(c, '\n'))) {
        std/core/True() -> "\\n"
        std/core/False() -> match ((std/core/(==){@}(c, '\r'))) {
          std/core/True() -> "\\r"
          std/core/False() -> match ((std/core/(==){@}(c, '\t'))) {
            std/core/True() -> "\\t"
            std/core/False() -> match ((std/core/(<=.1){@}((std/core/int{@}(c)), 255))) {
              std/core/True() -> std/core/(+.3){@}("\\x", (std/core/show-hex{0,4,fast}((std/core/int{@}(c)), (std/core/Optional(2)), std/core/None, (std/core/Optional("")))))
              std/core/False() -> match ((std/core/(<=.1){@}((std/core/int{@}(c)), 65535))) {
                std/core/True() -> std/core/(+.3){@}("\\u", (std/core/show-hex{0,4,fast}((std/core/int{@}(c)), (std/core/Optional(4)), std/core/None, (std/core/Optional("")))))
                std/core/False() -> std/core/(+.3){@}("\\U", (std/core/show-hex{0,4,fast}((std/core/int{@}(c)), (std/core/Optional(6)), std/core/None, (std/core/Optional("")))))
              }
            }
          }
        }
      }
      std/core/False() -> match ((std/core/(==){@}(c, '\''))) {
        std/core/True() -> "\\'"
        std/core/False() -> match ((std/core/(==){@}(c, '"'))) {
          std/core/True() -> "\\\""
          std/core/False() -> match ((std/core/(==){@}(c, '\\'))) {
            std/core/True() -> "\\\\"
            std/core/False() -> std/core/string{0,1,fast}(c)
          }
        }
      }
    }
  };
// Show a `:double` in exponential (scientific) notation.
// The optional `precision` (= `-17`) specifies the precision.
// If `>=0` it specifies the number of digits behind the dot (up to `17` max).
// If negative, then at most the absolute value of `precision` digits behind the dot are used.
public fun show-exp : (d : double, precision : ?int) -> string
  = fun(d:double, precision:?int){
    val .precision.17864 : int
          = match (precision) {
            std/core/Optional(.precision.17865) -> .precision.17865
            _ -> -17
          };
    std/core/show-expx{0,2,fast}(d, (std/core/int32{@}(.precision.17864)))
  };
// Show a `:double` fixed-point notation.
// The optional `precision` (= `-2`) specifies the maximum precision.
// If `>=0` it specifies the number of digits behind the dot (up to `20` max).
// If negative, then at most the absolute value of `precision` digits behind the dot are used.
// This may still show a number in exponential notation if the it is too small or large,
// in particular, for  a `d` where `d > 1.0e21` or `d < 1.0e-15`, or if
// `precision.abs > 17`, the `show-exp` routine is used.
public fun show-fixed : (d : double, precision : ?int) -> string
  = fun(d:double, precision:?int){
    val (.precision) .17876 : int
      = match (precision) {
        std/core/Optional(.precision.17877) -> .precision.17877
        _ -> -2
      };;
    val dabs : double
      = std/core/abs.1{@}(d);;
    match ((std/core/(||){@}((std/core/(<.3){@}(dabs, 1.0e-15)), (std/core/(>.2){@}(dabs, 1.0e21))))) {
      std/core/True() -> std/core/show-exp{0,2,fast}(d, (std/core/Optional(.precision.17876)))
      std/core/False() -> std/core/show-fixedx{0,2,fast}(d, (std/core/int32{@}(.precision.17876)))
    }
  };
// Convert a list to a string
public fun* (.bind-show-list) : forall<a,e> (xs : list<a>, show-elem : (a) -> e string) -> e string
  = forall<a,e> fun<e>(xs:list<a>, show-elem:(a) -> e string){
    std/core/bind{@}((std/core/(.bind-map.5){3,2,bind}(xs, show-elem)), (fun<e>(.y.273:list<string>){
        (std/core/(+.3){@}((std/core/(+.3){@}("[", (std/core/join.3{0,2,fast}(.y.273, ",")))), "]"))
      }))
  };
// Convert a list to a string
public fun (.fast-show-list) : forall<a,e> (xs : list<a>, show-elem : (a) -> e string) -> e string
  = forall<a,e> fun<e>(xs:list<a>, show-elem:(a) -> e string){
    std/core/(+.3){@}((std/core/(+.3){@}("[", (std/core/join.3{0,2,fast}((std/core/(.fast-map.5){3,2,fast}(xs, show-elem)), ",")))), "]")
  };
// Convert a list to a string
public fun** show-list : forall<a,e> (xs : list<a>, show-elem : (a) -> e string) -> e string
  = forall<a,e> fun<e>(xs:list<a>, show-elem:(a) -> e string){
    std/core/(.bind-show-list){2,2,bind}(xs, show-elem)
  };
// Show the exception message and its stack trace.
public fun show : (exn : exception) -> string
  = fun(exn:exception){
    std/core/stack-trace{0,1,fast}(exn)
  };
// Convert an `:int` to a string
public fun show .1 : (i : int) -> string
  = fun(i:int){
    std/core/gshow{1,1,fast}(i)
  };
// Convert a `:bool` to a string
public fun show .5 : (b : bool) -> string
  = fun(b:bool){
    match (b) {
      std/core/True() -> "True"
      std/core/False() -> "False"
    }
  };
public fun show .10 : (xs : list<bool>) -> string
  = fun(xs:list<bool>){
    std/core/show-list{2,2,poly}(xs, std/core/show.5{0,1,fast})
  };
// Show a `:double` as a string.
// If `d >= 1.0e-5` and `d < 1.0e+21`, `show-fixed` is used and otherwise `show-exp`.
// Default `precision` is `-17`.
public fun show .2 : (d : double, precision : ?int) -> string
  = fun(d:double, precision:?int){
    val (.precision) .18670 : int
      = match (precision) {
        std/core/Optional(.precision.18671) -> .precision.18671
        _ -> -17
      };;
    val dabs : double
      = std/core/abs.1{@}(d);;
    match ((std/core/(&&){@}((std/core/(>=.2){@}(dabs, 1.0e-5)), (std/core/(<.3){@}(dabs, 1.0e21))))) {
      std/core/True() -> std/core/show-fixed{0,2,fast}(d, (std/core/Optional(.precision.18670)))
      std/core/False() -> std/core/show-exp{0,2,fast}(d, (std/core/Optional(.precision.18670)))
    }
  };
// Show a `:char` as a character literal
public fun show .3 : (c : char) -> string
  = fun(c:char){
    std/core/(+.3){@}((std/core/(+.3){@}("'", (std/core/show-char{0,1,fast}(c)))), "'")
  };
// Show a string as a string literal
public fun show .4 : (s : string) -> string
  = fun(s:string){
    std/core/(+.3){@}((std/core/(+.3){@}("\"", (std/core/join.2{0,1,fast}((std/core/map.5{3,2,poly}((std/core/list.4{0,1,fast}(s)), std/core/show-char{0,1,fast})))))), "\"")
  };
// Convert a unit value `()` to a string
public fun show .6 : (u : ()) -> string
  = fun(u:()){
    "()"
  };
// Show an `:sslice` as a string literal
public fun show .7 : (s : sslice) -> string
  = fun(s:sslice){
    std/core/show.4{0,1,fast}((std/core/string.3{0,1,fast}(s)))
  };
public fun show .8 : (xs : list<string>) -> string
  = fun(xs:list<string>){
    std/core/show-list{2,2,poly}(xs, std/core/show.4{0,1,fast})
  };
public fun show .9 : (xs : list<int>) -> string
  = fun(xs:list<int>){
    std/core/show-list{2,2,poly}(xs, std/core/show.1{0,1,fast})
  };
// Print a string to the console.
public fun print : (s : string) -> console ()
  = fun<console>(s:string){
    std/core/prints{0,1,fast}(s)
  };
// Print an integer to the console.
public fun print .1 : (i : int) -> console ()
  = fun<console>(i:int){
    std/core/prints{0,1,fast}((std/core/show.1{0,1,fast}(i)))
  };
// Print a double to the console.
public fun print .2 : (d : double) -> console ()
  = fun<console>(d:double){
    std/core/prints{0,1,fast}((std/core/show.2{0,2,fast}(d, std/core/None)))
  };
// Print a boolean to the console
public fun print .3 : (b : bool) -> console ()
  = fun<console>(b:bool){
    std/core/prints{0,1,fast}((std/core/show.5{0,1,fast}(b)))
  };
// Print a character to the console.
public fun print .4 : (c : char) -> console ()
  = fun<console>(c:char){
    std/core/prints{0,1,fast}((std/core/string{0,1,fast}(c)))
  };
// Print a unit value to the console
public fun print .5 : (u : ()) -> console ()
  = fun<console>(u:()){
    std/core/prints{0,1,fast}((std/core/show.6{0,1,fast}(std/core/())))
  };
// Generic print routine: prints the internal representation as a string to the console,
// including a final newline character.
// Note: this breaks parametricity so it should not be public
fun gprint : forall<a> (x : a) -> console ()
  = forall<a> fun<console>(x:a){
    std/core/print{0,1,fast}((std/core/gshow{1,1,fast}(x)))
  };
fun printsln : (s : string) -> console ()
  = fun<console>(s:string){
    std/core/unsafe-total{2,1,fast}((fun<<console,read<global>>>(){
      match ((std/core/(!.1){@}(std/core/redirect))) {
        std/core/Nothing() -> std/core/xprintsln{0,1,fast}(s)
        std/core/Just(f) -> f((std/core/(+.3){@}(s, "\n")))
      }
    }))
  };
// Print a string to the console, including a final newline character.
public fun println : (s : string) -> console ()
  = fun<console>(s:string){
    std/core/printsln{0,1,fast}(s)
  };
// Print an integer to the console, including a final newline character.
public fun println .1 : (i : int) -> console ()
  = fun<console>(i:int){
    std/core/printsln{0,1,fast}((std/core/show.1{0,1,fast}(i)))
  };
// Print a double to the console, including a final newline character.
public fun println .2 : (d : double) -> console ()
  = fun<console>(d:double){
    std/core/printsln{0,1,fast}((std/core/show.2{0,2,fast}(d, std/core/None)))
  };
// Print a boolean to the console, including a final newline character
public fun println .3 : (b : bool) -> console ()
  = fun<console>(b:bool){
    std/core/printsln{0,1,fast}((std/core/show.5{0,1,fast}(b)))
  };
// Print a character to the console, including a final newline character.
public fun println .4 : (c : char) -> console ()
  = fun<console>(c:char){
    std/core/printsln{0,1,fast}((std/core/string{0,1,fast}(c)))
  };
// Print a unit value to the console, including a final newline character
public fun println .5 : (u : ()) -> console ()
  = fun<console>(u:()){
    std/core/printsln{0,1,fast}((std/core/show.6{0,1,fast}(std/core/())))
  };
// Generic print routine: prints the internal representation as a string to the console, including a final newline character.
// Note: this breaks parametricity so it should not be public
fun gprintln : forall<a> (x : a) -> console ()
  = forall<a> fun<console>(x:a){
    std/core/println{0,1,fast}((std/core/gshow{1,1,fast}(x)))
  };
// Return the head of list if the list is not empty.
public fun head .1 : forall<a> (xs : list<a>) -> maybe<a>
  = forall<a> fun(xs:list<a>){
    match (xs) {
      std/core/Cons(x, _) -> std/core/Just(x)
      _ -> std/core/Nothing
    }
  };
// Return the head of list if the list is not empty, or use `default` otherwise
public fun head .2 : forall<a> (xs : list<a>, default : a) -> a
  = forall<a> fun(xs:list<a>, default0:a){
    match (xs) {
      std/core/Cons(x, _) -> x
      _ -> default0
    }
  };
// Return the first character of a string as a string (or the empty string)
public fun head .3 : (s : string) -> string
  = fun(s:string){
    std/core/string.3{0,1,fast}((std/core/first{0,2,fast}(s, std/core/None)))
  };
// Return the first character of a string (or `Nothing` for the empty string).
public fun head-char : (s : string) -> maybe<char>
  = fun(s:string){
    std/core/foreach-while.2{2,2,poly}(s, std/core/Just)
  };
// Is the character an ASCII hexa-decimal digit ?
public fun hex-digit? : (c : char) -> bool
  = fun(c:char){
    std/core/(||){@}((std/core/digit?{0,1,fast}(c)), (std/core/(||){@}((std/core/(&&){@}((std/core/(>=){@}(c, 'a')), (std/core/(<=){@}(c, 'f')))), (std/core/(&&){@}((std/core/(>=){@}(c, 'A')), (std/core/(<=){@}(c, 'F')))))))
  };
fun index-of-acc : forall<a> (xs : list<a>, pred : (a) -> bool, idx : int) -> int
  = forall<a> fun(xs:list<a>, pred:(a) -> bool, idx:int){
    match (xs) {
      std/core/Nil() -> std/core/(-){@}(0, 1)
      std/core/Cons(x, xx) -> match ((pred(x))) {
        std/core/True() -> idx
        std/core/False() -> std/core/index-of-acc{1,3,fast}(xx, pred, (std/core/(+){@}(idx, 1)))
      }
    }
  };
// Returns the index of the first element where `pred` holds, or `-1` if no such element exists.
public fun index-of : forall<a> (xs : list<a>, pred : (a) -> bool) -> int
  = forall<a> fun(xs:list<a>, pred:(a) -> bool){
    std/core/index-of-acc{1,3,fast}(xs, pred, 0)
  };
// Return the list without its last element.
// Return an empty list for an empty list.
public fun init : forall<a> (xs : list<a>) -> list<a>
  = forall<a> fun(xs:list<a>){
    match (xs) {
      std/core/Cons(x, xx) -> match (xx) {
        std/core/Nil() -> std/core/Nil
        _ -> std/core/Cons(x, (std/core/init{1,1,fast}(xx)))
      }
      std/core/Nil() -> std/core/Nil
    }
  };
// Append `end` to each string in the list `xs` and join them all together.\
// `join-end([],end) === ""`\
// `join-end(["a","b"],"/") === "a/b/"`
public fun join-end : (xs : list<string>, end : string) -> string
  = fun(xs:list<string>, end:string){
    match (xs) {
      std/core/Nil() -> ""
      _ -> std/core/(+.3){@}((std/core/joinsep{0,2,fast}(xs, end)), end)
    }
  };
// Return the last element of a list (or `Nothing` for the empty list)
public fun last : forall<a> (xs : list<a>) -> maybe<a>
  = forall<a> fun(xs:list<a>){
    match (xs) {
      std/core/Cons(x, std/core/Nil()) -> std/core/Just(x)
      std/core/Cons(_, xx) -> std/core/last{1,1,fast}(xx)
      std/core/Nil() -> std/core/Nothing
    }
  };
// Return the last element of a list (or `default` for the empty list)
public fun last .1 : forall<a> (xs : list<a>, default : a) -> a
  = forall<a> fun(xs:list<a>, default0:a){
    match (xs) {
      std/core/Cons(x, std/core/Nil()) -> x
      std/core/Cons(_, xx) -> std/core/last.1{1,2,fast}(xx, default0)
      std/core/Nil() -> default0
    }
  };
// O(`n`). The last `n` (default = `1`) characters in a string
public fun last .2 : (s : string, n : ?int) -> sslice
  = fun(s:string, n:?int){
    val (.n) .21046 : int
      = match (n) {
        std/core/Optional(.n.21047) -> .n.21047
        _ -> 1
      };;
    val slice0 : sslice
      = std/core/last1{@}(s);;
    match ((std/core/(==.1){@}(.n.21046, 1))) {
      std/core/True() -> slice0
      std/core/False() -> std/core/extend{0,2,fast}((std/core/advance{0,2,fast}(slice0, (std/core/(-){@}(1, .n.21046)))), (std/core/(-){@}(.n.21046, 1)))
    }
  };
// Take the first `n` elements of a list (or fewer if the list is shorter than `n`)
public fun take : forall<a> (xs : list<a>, n : int) -> list<a>
  = forall<a> fun(xs:list<a>, n:int){
    match ((std/core/(<=.1){@}(n, 0))) {
      std/core/True() -> std/core/Nil
      std/core/False() -> match (xs) {
        std/core/Nil() -> std/core/Nil
        std/core/Cons(x, xx) -> std/core/Cons(x, (std/core/take{1,2,fast}(xx, (std/core/(-){@}(n, 1)))))
      }
    }
  };
// split a list at position `n`
public fun split : forall<a> (xs : list<a>, n : int) -> (list<a>, list<a>)
  = forall<a> fun(xs:list<a>, n:int){
    std/core/(,)((std/core/take{1,2,fast}(xs, n)), (std/core/drop{1,2,fast}(xs, n)))
  };
// Split a string into parts that were delimited by `sep`. The delimeters are not included in the results.
// For example: `split("1,,2",",") == ["1","","2]`
public fun split .1 : (s : string, sep : string) -> list<string>
  = fun(s:string, sep:string){
    std/core/list.5{1,1,fast}((std/core/splitv{@}(s, sep)))
  };
// Split a string into at most `n` parts that were delimited by a string `sep`. The delimeters are not included in the results (except for possibly the final part).
// For example: `split("1,2,3",",",2) == ["1","2,3"]`
public fun split .2 : (s : string, sep : string, n : int) -> list<string>
  = fun(s:string, sep:string, n:int){
    std/core/list.5{1,1,fast}((std/core/splitv.1{@}(s, sep, (std/core/int32{@}(n)))))
  };
// Split a string into a list of lines
public fun lines : (s : string) -> list<string>
  = fun(s:string){
    std/core/split.1{0,2,fast}(s, "\n")
  };
// Lookup the first element satisfying some predicate
public fun lookup : forall<a,b> (xs : list<(a, b)>, pred : (a) -> bool) -> maybe<b>
  = forall<a,b> fun(xs:list<(a, b)>, pred:(a) -> bool){
    std/core/foreach-while{3,2,poly}(xs, (fun(kv:(a, b)){
        match ((pred((std/core/fst{2,1,fast}(kv))))) {
          std/core/True() -> std/core/Just((std/core/snd{2,1,fast}(kv)))
          std/core/False() -> std/core/Nothing
        }
      }))
  };
// Apply a function `f`  to each element of the input list in sequence where takes
// both the index of the current element and the element itself as arguments.
public fun* (.bind-map-indexed) : forall<a,b,e> (xs : list<a>, f : (idx : int, value : a) -> e b) -> e list<b>
  = forall<a,b,e> fun<e>(xs:list<a>, f:(idx : int, value : a) -> e b){
    std/core/(.bind-map-indexed-peek){3,2,bind}(xs, (fun<e>(i:int, x:a, xx:list<a>){
        (f(i, x))
      }))
  };
// Apply a function `f`  to each element of the input list in sequence where takes
// both the index of the current element and the element itself as arguments.
public fun (.fast-map-indexed) : forall<a,b,e> (xs : list<a>, f : (idx : int, value : a) -> e b) -> e list<b>
  = forall<a,b,e> fun<e>(xs:list<a>, f:(idx : int, value : a) -> e b){
    std/core/(.fast-map-indexed-peek){3,2,fast}(xs, (fun<e>(i:int, x:a, xx:list<a>){
        (f(i, x))
      }))
  };
// Apply a function `f`  to each element of the input list in sequence where takes
// both the index of the current element and the element itself as arguments.
public fun** map-indexed : forall<a,b,e> (xs : list<a>, f : (idx : int, value : a) -> e b) -> e list<b>
  = forall<a,b,e> fun<e>(xs:list<a>, f:(idx : int, value : a) -> e b){
    std/core/(.bind-map-indexed){3,2,bind}(xs, f)
  };
// Apply a function `f`  to each element of the input list in sequence where `f` takes
// both the current element and the tail list as arguments.
public fun* (.bind-map-peek) : forall<a,b,e> (xs : list<a>, f : (value : a, rest : list<a>) -> e b) -> e list<b>
  = forall<a,b,e> fun<e>(xs:list<a>, f:(value : a, rest : list<a>) -> e b){
    std/core/(.bind-map-indexed-peek){3,2,bind}(xs, (fun<e>(i:int, x:a, xx:list<a>){
        (f(x, xx))
      }))
  };
// Apply a function `f`  to each element of the input list in sequence where `f` takes
// both the current element and the tail list as arguments.
public fun (.fast-map-peek) : forall<a,b,e> (xs : list<a>, f : (value : a, rest : list<a>) -> e b) -> e list<b>
  = forall<a,b,e> fun<e>(xs:list<a>, f:(value : a, rest : list<a>) -> e b){
    std/core/(.fast-map-indexed-peek){3,2,fast}(xs, (fun<e>(i:int, x:a, xx:list<a>){
        (f(x, xx))
      }))
  };
// Apply a function `f`  to each element of the input list in sequence where `f` takes
// both the current element and the tail list as arguments.
public fun** map-peek : forall<a,b,e> (xs : list<a>, f : (value : a, rest : list<a>) -> e b) -> e list<b>
  = forall<a,b,e> fun<e>(xs:list<a>, f:(value : a, rest : list<a>) -> e b){
    std/core/(.bind-map-peek){3,2,bind}(xs, f)
  };
// Invoke `action` on each element of a list while `action` returns `Just`
public fun* (.bind-map-while) : forall<a,b,e> (xs : list<a>, action : (a) -> e maybe<b>) -> e list<b>
  = forall<a,b,e> fun<e>(xs:list<a>, action:(a) -> e maybe<b>){
    match (xs) {
      std/core/Nil() -> std/core/Nil
      std/core/Cons(x, xx) -> std/core/bind{@}((action(x)), (fun<e>(.y.281:maybe<b>){
          match (.y.281) {
            std/core/Just(y) -> std/core/bind{@}((std/core/(.bind-map-while){3,2,bind}(xx, action)), (fun<e>(.y.282:list<b>){
                (std/core/Cons(y, .y.282))
              }))
            std/core/Nothing() -> std/core/Nil
          }
        }))
    }
  };
// Invoke `action` on each element of a list while `action` returns `Just`
public fun (.fast-map-while) : forall<a,b,e> (xs : list<a>, action : (a) -> e maybe<b>) -> e list<b>
  = forall<a,b,e> fun<e>(xs0:list<a>, action0:(a) -> e maybe<b>){
    match (xs0) {
      std/core/Nil() -> std/core/Nil
      std/core/Cons(x0, xx0) -> match ((action0(x0))) {
        std/core/Just(y0) -> std/core/Cons(y0, (std/core/(.fast-map-while){3,2,fast}(xx0, action0)))
        std/core/Nothing() -> std/core/Nil
      }
    }
  };
// Invoke `action` on each element of a list while `action` returns `Just`
public fun** map-while : forall<a,b,e> (xs : list<a>, action : (a) -> e maybe<b>) -> e list<b>
  = forall<a,b,e> fun<e>(xs1:list<a>, action1:(a) -> e maybe<b>){
    std/core/(.bind-map-while){3,2,bind}(xs1, action1)
  };
// Returns the largest element of a list of integers (or `default` (=`0`) for the empty list)
public fun maximum : (xs : list<int>, default : ?int) -> int
  = fun(xs:list<int>, default0:?int){
    val .default.21720 : int
          = match (default0) {
            std/core/Optional(.default.21721) -> .default.21721
            _ -> 0
          };
    match (xs) {
      std/core/Nil() -> .default.21720
      std/core/Cons(x, xx) -> std/core/foldl{3,3,poly}(xx, x, std/core/max{0,2,fast})
    }
  };
// Returns the largest element of a list of doubles (or `0` for the empty list)
public fun maximum .1 : (xs : list<double>) -> double
  = fun(xs:list<double>){
    match (xs) {
      std/core/Nil() -> 0.0
      std/core/Cons(x, xx) -> std/core/foldl{3,3,poly}(xx, x, std/core/max.1{0,2,fast})
    }
  };
// Transform a `:try` type to a `:maybe` value.
public fun maybe : forall<a> (t : try<a>) -> maybe<exception>
  = forall<a> fun(t:try<a>){
    match (t) {
      std/core/Exn(exn) -> std/core/Just(exn)
      std/core/Ok(_) -> std/core/Nothing
    }
  };
// Transform a `:null` type to a `:maybe` type. Note that it is not
// always the case that `id(x) == maybe(null(x))` (e.g. when `x = Just(Nothing)`).
public fun maybe .1 : forall<a> (n : null<a>) -> maybe<a>
  = forall<a> fun(n:null<a>){
    std/core/(.extern-maybe){@}(n)
  };
// Match a `:maybe` value and either return a default value on `Nothing` or apply a function to the value on `Just`
public fun* (.bind-maybe) .2 : forall<a,b,e> (m : maybe<a>, onNothing : b, onJust : (a) -> e b) -> e b
  = forall<a,b,e> fun<e>(m:maybe<a>, onNothing:b, onJust:(a) -> e b){
    match (m) {
      std/core/Nothing() -> onNothing
      std/core/Just(x) -> onJust(x)
    }
  };
// Match a `:maybe` value and either return a default value on `Nothing` or apply a function to the value on `Just`
public fun (.fast-maybe) .2 : forall<a,b,e> (m : maybe<a>, onNothing : b, onJust : (a) -> e b) -> e b
  = forall<a,b,e> fun<e>(m:maybe<a>, onNothing:b, onJust:(a) -> e b){
    match (m) {
      std/core/Nothing() -> onNothing
      std/core/Just(x) -> onJust(x)
    }
  };
// Match a `:maybe` value and either return a default value on `Nothing` or apply a function to the value on `Just`
public fun** maybe .2 : forall<a,b,e> (m : maybe<a>, onNothing : b, onJust : (a) -> e b) -> e b
  = forall<a,b,e> fun<e>(m:maybe<a>, onNothing:b, onJust:(a) -> e b){
    std/core/(.bind-maybe.2){3,3,bind}(m, onNothing, onJust)
  };
// Convert a `:maybe<a>` value to `:a`, using the `nothing` parameter for `Nothing`.
// This is an alias for `default`.
public fun maybe .3 : forall<a> (m : maybe<a>, nothing : a) -> a
  = forall<a> fun(m:maybe<a>, nothing:a){
    std/core/default{1,2,fast}(m, nothing)
  };
// Convert a `:either` to a `:maybe` type discarding the value of the `Left` constructor
// and using `Just` for the `Right` constructor.
public fun maybe .4 : forall<a,b> (e : either<a,b>) -> maybe<b>
  = forall<a,b> fun(e:either<a,b>){
    match (e) {
      std/core/Left(_) -> std/core/Nothing
      std/core/Right(x) -> std/core/Just(x)
    }
  };
// Convert a list to a `:maybe` type, using `Nothing` for an empty list, and otherwise `Just` on the head element.
// Note: this is just `head`.
public fun maybe .5 : forall<a> (xs : list<a>) -> maybe<a>
  = forall<a> fun(xs:list<a>){
    match (xs) {
      std/core/Nil() -> std/core/Nothing
      std/core/Cons(x, _) -> std/core/Just(x)
    }
  };
// Transform a boolean to a maybe type, using `Nothing` for `False`
public fun maybe .6 : (b : bool) -> maybe<()>
  = fun(b:bool){
    match (b) {
      std/core/True() -> std/core/Just(std/core/())
      std/core/False() -> std/core/Nothing
    }
  };
// Transform an integer to a maybe type, using `Nothing` for `0`
public fun maybe .7 : (i : int) -> maybe<int>
  = fun(i:int){
    match ((std/core/(==.1){@}(i, 0))) {
      std/core/True() -> std/core/Nothing
      std/core/False() -> std/core/Just(i)
    }
  };
// Transform a string to a maybe type, using `Nothing` for an empty string
public fun maybe .8 : (s : string) -> maybe<string>
  = fun(s:string){
    match ((std/core/empty?.1{0,1,fast}(s))) {
      std/core/True() -> std/core/Nothing
      std/core/False() -> std/core/Just(s)
    }
  };
// Returns the smallest element of a list of integers (or `default` (=`0`) for the empty list)
public fun minimum : (xs : list<int>, default : ?int) -> int
  = fun(xs:list<int>, default0:?int){
    val .default.22229 : int
          = match (default0) {
            std/core/Optional(.default.22230) -> .default.22230
            _ -> 0
          };
    match (xs) {
      std/core/Nil() -> .default.22229
      std/core/Cons(x, xx) -> std/core/foldl{3,3,poly}(xx, x, std/core/min{0,2,fast})
    }
  };
// Returns the smallest element of a list of doubles (or `0` for the empty list)
public fun minimum .1 : (xs : list<double>) -> double
  = fun(xs:list<double>){
    match (xs) {
      std/core/Nil() -> 0.0
      std/core/Cons(x, xx) -> std/core/foldl{3,3,poly}(xx, x, std/core/min.1{0,2,fast})
    }
  };
// Is a slice not empty?
public fun notempty? : (slice : sslice) -> bool
  = fun(slice0:sslice){
    std/core/pos?{@}((std/core/len{0,1,fast}(slice0)))
  };
// Is a string not empty?
public fun notempty? .1 : (s : string) -> bool
  = fun(s:string){
    std/core/(!=.3){@}(s, "")
  };
val trace-enabled : ref<global,bool>
  = std/core/unsafe-total{2,1,fast}((fun<(alloc<global>)>(){
    (std/core/ref{@}(std/core/True))
  }));
// Disable tracing completely.
public fun notrace : () -> (st<global>) ()
  = fun<<alloc<global>,read<global>,write<global>>>(){
    std/core/set{@}(std/core/trace-enabled, std/core/False)
  };
// Transform a `:maybe` type to a `:null` type (using `null` for `Nothing`).
public fun null : forall<a> (x : maybe<a>) -> null<a>
  = forall<a> fun(x:maybe<a>){
    std/core/(.extern-null){@}(x)
  };
// Cast a integer that is zero to a null
public fun null .1 : (i : int) -> null<int>
  = fun(i:int){
    std/core/null{1,1,fast}((std/core/maybe.7{0,1,fast}(i)))
  };
// Cast an empty string a null
public fun null .2 : (s : string) -> null<string>
  = fun(s:string){
    std/core/null{1,1,fast}((std/core/maybe.8{0,1,fast}(s)))
  };
// Cast a boolean `False` to null
public fun null .3 : (b : bool) -> null<()>
  = fun(b:bool){
    std/core/null{1,1,fast}((std/core/maybe.6{0,1,fast}(b)))
  };
public val null-const : forall<a> null<a>
  = forall<a> std/core/null{1,1,fast}(std/core/Nothing);
public val null-return : forall<a,e> null<(a) -> e a>
  = forall<a,e> std/core/null-const;
public val null-return1 : forall<a,b,e> null<(a, b) -> e a>
  = forall<a,b,e> std/core/null-const;
// Set a `hndler` that is always called when the `action` finishes (either normally or with an exception).
// Note that `on-exit(handler,action) == finally(action,handler)`.
public fun* (.bind-on-exit) : forall<a,e> (hndler : () -> e (), action : () -> e a) -> e a
  = forall<a,e> fun<e>(hndler:() -> e (), action:() -> e a){
    std/core/(.bind-finally){2,2,bind}(action, hndler)
  };
// Set a `hndler` that is always called when the `action` finishes (either normally or with an exception).
// Note that `on-exit(handler,action) == finally(action,handler)`.
public fun (.fast-on-exit) : forall<a,e> (hndler : () -> e (), action : () -> e a) -> e a
  = forall<a,e> fun<e>(hndler:() -> e (), action:() -> e a){
    std/core/(.fast-finally){2,2,fast}(action, hndler)
  };
// Set a `hndler` that is always called when the `action` finishes (either normally or with an exception).
// Note that `on-exit(handler,action) == finally(action,handler)`.
public fun** on-exit : forall<a,e> (hndler : () -> e (), action : () -> e a) -> e a
  = forall<a,e> fun<e>(hndler:() -> e (), action:() -> e a){
    std/core/(.bind-on-exit){2,2,bind}(hndler, action)
  };
// Set a `hndler` that is called only when an exception is raised in the `action` block.
public fun* (.bind-on-exn) : forall<a,e> (hndler : (exception) -> <exn|e> (), action : () -> <exn|e> a) -> <exn|e> a
  = forall<a,e> fun<<exn|e>>(hndler:(exception) -> <exn|e> (), action:() -> <exn|e> a){
    std/core/(.bind-prim-try-some){2,2,bind}(action, (fun<<exn|e>>(exn:exception){
        (std/core/bind{@}((hndler(exn)), (fun<<exn|e>>(_:()){
            (std/core/throw{1,1,fast}(exn))
          })))
      }))
  };
// Set a `hndler` that is called only when an exception is raised in the `action` block.
public fun (.fast-on-exn) : forall<a,e> (hndler : (exception) -> <exn|e> (), action : () -> <exn|e> a) -> <exn|e> a
  = forall<a,e> fun<<exn|e>>(hndler:(exception) -> <exn|e> (), action:() -> <exn|e> a){
    std/core/(.fast-prim-try-some){2,2,fast}(action, (fun<<exn|e>>(exn:exception){
        val _ : ()
              = (hndler(exn));
        (std/core/throw{1,1,fast}(exn))
      }))
  };
// Set a `hndler` that is called only when an exception is raised in the `action` block.
public fun** on-exn : forall<a,e> (hndler : (exception) -> <exn|e> (), action : () -> <exn|e> a) -> <exn|e> a
  = forall<a,e> fun<<exn|e>>(hndler:(exception) -> <exn|e> (), action:() -> <exn|e> a){
    std/core/(.bind-on-exn){2,2,bind}(hndler, action)
  };
// Given a total function to calculate a value `:a`, return
// a total function that only calculates the value once and then
// returns the cached result.
public fun once : forall<a> (calc : () -> a) -> (() -> a)
  = forall<a> fun(calc:() -> a){
    std/core/unsafe-total{2,1,fast}((fun(){
      val value : (ref<void,maybe<a>>)
            = (std/core/ref{@}(std/core/Nothing));
      (std/core/(.return){@}((fun(){
        (std/core/unsafe-total{2,1,fast}((fun<<div,read<void>,write<void>>>(){
          match ((std/core/(!.1){@}(value))) {
            std/core/Just(x) -> x
            std/core/Nothing() -> val x0 : a
                                    = calc();;
                                  val _ : ()
                                    = std/core/set{@}(value, (std/core/Just(x0)));;
            x0
          }
        })))
      })))
    }))
  };
// Left-align a string to width `width`  using `fill`  (default is a space) to fill on the right.
public fun pad-right : (s : string, width : int, fill : ?char) -> string
  = fun(s:string, width:int, fill:?char){
    val (.fill) .23035 : char
      = match (fill) {
        std/core/Optional(.fill.23036) -> .fill.23036
        _ -> ' '
      };;
    val w : int32
      = std/core/int32{@}(width);;
    val n : int32
      = std/core/length{@}(s);;
    match ((std/core/(<=.2){@}(w, n))) {
      std/core/True() -> s
      std/core/False() -> std/core/(+.3){@}(s, (std/core/repeat32{0,2,fast}((std/core/string{0,1,fast}(.fill.23035)), (std/core/(-.1){@}(w, n)))))
    }
  };
// Is `pre`  a prefix of `s`? If so, returns a slice
// of `s` following `pre` up to the end of `s`.
public fun starts-with : (s : string, pre : string) -> maybe<sslice>
  = fun(s:string, pre:string){
    match ((std/core/xstarts-with{@}(s, pre))) {
      std/core/True() -> std/core/Just((std/core/Sslice(s, (std/core/length{@}(pre)), (std/core/(-.1){@}((std/core/length{@}(s)), (std/core/length{@}(pre)))))))
      std/core/False() -> std/core/Nothing
    }
  };
// Trim off a substring `sub` while `s` starts with that string.
public fun trim-left .1 : (s : string, sub : string) -> string
  = fun(s:string, sub:string){
    match ((std/core/empty?.1{0,1,fast}(sub))) {
      std/core/True() -> s
      std/core/False() -> match ((std/core/starts-with{0,2,fast}(s, sub))) {
        std/core/Just(slice0) -> std/core/trim-left.1{0,2,fast}((std/core/unsafe-decreasing{@}((std/core/string.3{0,1,fast}(slice0)))), sub)
        std/core/Nothing() -> s
      }
    }
  };
// Trim off a substring `sub` while `s` ends with that string.
public fun trim-right .1 : (s : string, sub : string) -> string
  = fun(s:string, sub:string){
    match ((std/core/empty?.1{0,1,fast}(sub))) {
      std/core/True() -> s
      std/core/False() -> match ((std/core/ends-with{0,2,fast}(s, sub))) {
        std/core/Just(slice0) -> std/core/trim-right.1{0,2,fast}((std/core/unsafe-decreasing{@}((std/core/string.3{0,1,fast}(slice0)))), sub)
        std/core/Nothing() -> s
      }
    }
  };
// Trim whitespace on the left and right side of a string
public fun trim : (s : string) -> string
  = fun(s:string){
    std/core/trim-right{@}((std/core/trim-left{@}(s)))
  };
// Parse an integer after trimming whitespace.
// If an illegal digit character is encountered `Nothing` is returned.
// An empty string will result in `Just(0)`.
// A string can start with a `-` sign for negative numbers,
// and with `0x` or `0X` for hexadecimal numbers (in which case the `hex` parameter is ignored).
public fun parse-int : (s : string, hex : ?bool) -> maybe<int>
  = fun(s:string, hex:?bool){
    val .hex.23424 : bool
          = match (hex) {
            std/core/Optional(.hex.23425) -> .hex.23425
            _ -> std/core/False
          };
    std/core/xparse-int{0,2,fast}((std/core/trim{0,1,fast}(s)), .hex.23424)
  };
// Parse an integer using `parseInt`. If an illegal digit character is encountered the
// `default` value is returned. An empty string will also result in `default`.
public fun parse-int-default : (s : string, default : ?int, hex : ?bool) -> int
  = fun(s:string, default0:?int, hex:?bool){
    val (.default) .23436 : int
      = match (default0) {
        std/core/Optional(.default.23437) -> .default.23437
        _ -> 0
      };;
    val (.hex) .23440 : bool
      = match (hex) {
        std/core/Optional(.hex.23441) -> .hex.23441
        _ -> std/core/False
      };;
    match ((std/core/empty?.1{0,1,fast}(s))) {
      std/core/True() -> .default.23436
      std/core/False() -> std/core/maybe.3{1,2,fast}((std/core/parse-int{0,2,fast}(s, (std/core/Optional(.hex.23440)))), .default.23436)
    }
  };
fun partition-acc : forall<a> (xs : list<a>, pred : (a) -> bool, acc1 : list<a>, acc2 : list<a>) -> (list<a>, list<a>)
  = forall<a> fun(xs:list<a>, pred:(a) -> bool, acc1:list<a>, acc2:list<a>){
    match (xs) {
      std/core/Nil() -> std/core/(,)((std/core/reverse{1,1,fast}(acc1)), (std/core/reverse{1,1,fast}(acc2)))
      std/core/Cons(x, xx) -> match ((pred(x))) {
        std/core/True() -> std/core/partition-acc{1,4,fast}(xx, pred, (std/core/Cons(x, acc1)), acc2)
        std/core/False() -> std/core/partition-acc{1,4,fast}(xx, pred, acc1, (std/core/Cons(x, acc2)))
      }
    }
  };
// Partition a list in two lists where the first list contains
// those elements that satisfy the given predicate `pred`.
// For example: `partition([1,2,3],odd?) == ([1,3],[2])`
public fun partition : forall<a> (xs : list<a>, pred : (a) -> bool) -> (list<a>, list<a>)
  = forall<a> fun(xs:list<a>, pred:(a) -> bool){
    std/core/partition-acc{1,4,fast}(xs, pred, std/core/Nil, std/core/Nil)
  };
// redirect `print` and `println` calls to a specified function.
public fun print-redirect : (print : (msg : string) -> console ()) -> io ()
  = fun<<ui,div,exn,net,alloc<global>,console,file,ndet,read<global>,write<global>>>(print0:(msg : string) -> console ()){
    std/core/set{@}(std/core/redirect, (std/core/Just(print0)))
  };
// Remove those elements of a list that satisfy the given predicate `pred`.
// For example: `remove([1,2,3],odd?) == [2]`
public fun remove : forall<a> (xs : list<a>, pred : (a) -> bool) -> list<a>
  = forall<a> fun(xs:list<a>, pred:(a) -> bool){
    std/core/filter{2,2,poly}(xs, (fun(x:a){
        (std/core/(!){@}((pred(x))))
      }))
  };
// Repeat a string `n` times
public fun repeat : (s : string, n : int) -> string
  = fun(s:string, n:int){
    std/core/repeat32{0,2,fast}(s, (std/core/int32{@}(n)))
  };
// The `repeat` fun executes `action`  `n`  times.
public fun* (.bind-repeat) .1 : forall<e> (n : int, action : () -> e ()) -> e ()
  = forall<e> fun<e>(n:int, action:() -> e ()){
    std/core/(.bind-for){1,3,bind}(1, n, (fun<e>(i:int){
        (action())
      }))
  };
// The `repeat` fun executes `action`  `n`  times.
public fun (.fast-repeat) .1 : forall<e> (n : int, action : () -> e ()) -> e ()
  = forall<e> fun<e>(n:int, action:() -> e ()){
    std/core/(.fast-for){1,3,fast}(1, n, (fun<e>(i:int){
        (action())
      }))
  };
// The `repeat` fun executes `action`  `n`  times.
public fun** repeat .1 : forall<e> (n : int, action : () -> e ()) -> e ()
  = forall<e> fun<e>(n:int, action:() -> e ()){
    std/core/(.bind-repeat.1){1,2,bind}(n, action)
  };
// Create a list of `n`  repeated elementes `x`
public fun replicate : forall<a> (x : a, n : int) -> list<a>
  = forall<a> fun(x:a, n:int){
    val enumerate : (i : int, acc : list<a>) -> list<a>
      = fun(i:int, acc:list<a>){
        match ((std/core/(<=.1){@}(i, 0))) {
          std/core/True() -> acc
          std/core/False() -> enumerate((std/core/unsafe-decreasing{@}((std/core/dec{0,1,fast}(i)))), (std/core/Cons(x, acc)))
        }
      };;
    enumerate(n, std/core/Nil)
  };
public fun show-tuple : forall<a,b> (x : (a, b), showfst : (a) -> string, showsnd : (b) -> string) -> string
  = forall<a,b> fun(x:(a, b), showfst:(a) -> string, showsnd:(b) -> string){
    std/core/(+.3){@}((std/core/(+.3){@}((std/core/(+.3){@}((std/core/(+.3){@}("(", (showfst((std/core/fst{2,1,fast}(x)))))), ",")), (showsnd((std/core/snd{2,1,fast}(x)))))), ")")
  };
// Return the tail of list. Returns the empty list if `xs` is empty.
public fun tail .1 : forall<a> (xs : list<a>) -> list<a>
  = forall<a> fun(xs:list<a>){
    match (xs) {
      std/core/Cons(_, xx) -> xx
      _ -> std/core/Nil
    }
  };
// Return the tail of a string (or the empty string)
public fun tail .2 : (s : string) -> string
  = fun(s:string){
    std/core/string.3{0,1,fast}((std/core/after{0,1,fast}((std/core/first{0,2,fast}(s, std/core/None)))))
  };
// Keep only those initial elements that satisfy `predicate`
public fun* (.bind-take-while) : forall<a,e> (xs : list<a>, predicate : (a) -> e bool) -> e list<a>
  = forall<a,e> fun<e>(xs:list<a>, predicate:(a) -> e bool){
    std/core/bind{@}((std/core/(.bind-span){2,2,bind}(xs, predicate)), (fun<e>(.y.294:(list<a>, list<a>)){
        (std/core/fst{2,1,fast}(.y.294))
      }))
  };
// Keep only those initial elements that satisfy `predicate`
public fun (.fast-take-while) : forall<a,e> (xs : list<a>, predicate : (a) -> e bool) -> e list<a>
  = forall<a,e> fun<e>(xs:list<a>, predicate:(a) -> e bool){
    std/core/fst{2,1,fast}((std/core/(.fast-span){2,2,fast}(xs, predicate)))
  };
// Keep only those initial elements that satisfy `predicate`
public fun** take-while : forall<a,e> (xs : list<a>, predicate : (a) -> e bool) -> e list<a>
  = forall<a,e> fun<e>(xs:list<a>, predicate:(a) -> e bool){
    std/core/(.bind-take-while){2,2,bind}(xs, predicate)
  };
public fun todo : (message : string) -> ()
  = fun(message0:string){
    std/core/unsafe-noexn{2,1,poly}((fun<exn>(){
      (std/core/throw.1{1,2,fast}(message0, (std/core/Optional(std/core/Todo))))
    }))
  };
// Trace a message used for debug purposes.
// The behaviour is system dependent. On a browser and node it uses
// `console.log`  by default.
// Disabled if `notrace` is called.
public fun trace : (message : string) -> ()
  = fun(message0:string){
    std/core/unsafe-total{2,1,fast}((fun<(read<global>)>(){
      match ((std/core/(!.1){@}(std/core/trace-enabled))) {
        std/core/True() -> std/core/xtrace{0,1,fast}(message0)
        std/core/False() -> std/core/()
      }
    }))
  };
public fun trace-any : forall<a> (message : string, x : a) -> ()
  = forall<a> fun(message0:string, x:a){
    std/core/unsafe-total{2,1,fast}((fun<(read<global>)>(){
      match ((std/core/(!.1){@}(std/core/trace-enabled))) {
        std/core/True() -> std/core/xtrace-any{1,2,fast}(message0, x)
        std/core/False() -> std/core/()
      }
    }))
  };
// Truncate a string to `count` characters.
public fun truncate : (s : string, count : int) -> string
  = fun(s:string, count:int){
    std/core/string.3{0,1,fast}((std/core/extend{0,2,fast}((std/core/first{0,2,fast}(s, std/core/None)), (std/core/(-){@}(count, 1)))))
  };
// Return a default value when an exception is raised
public fun* (.bind-try-default) : forall<a,e> (value : a, action : () -> <exn|e> a) -> e a
  = forall<a,e> fun<e>(value:a, action:() -> <exn|e> a){
    std/core/(.bind-try){2,2,bind}(action, (fun<e>(_(285,20):exception){
        value
      }))
  };
// Return a default value when an exception is raised
public fun (.fast-try-default) : forall<a,e> (value : a, action : () -> <exn|e> a) -> e a
  = forall<a,e> fun<e>(value:a, action:() -> <exn|e> a){
    std/core/(.fast-try){2,2,fast}(action, (fun<e>(_(285,20):exception){
        value
      }))
  };
// Return a default value when an exception is raised
public fun** try-default : forall<a,e> (value : a, action : () -> <exn|e> a) -> e a
  = forall<a,e> fun<e>(value:a, action:() -> <exn|e> a){
    std/core/(.bind-try-default){2,2,bind}(value, action)
  };
val unique-count : ref<global,int>
  = std/core/unsafe-total{2,1,fast}((fun<(alloc<global>)>(){
    (std/core/ref{@}(0))
  }));
// Returns a unique integer (modulo 32-bits).
public fun unique : () -> ndet int
  = fun<ndet>(){
    std/core/unsafe-total{2,1,fast}((fun<<read<global>,write<global>>>(){
      val u : int
        = (std/core/(!.1){@}(std/core/unique-count));;
      val _ : ()
        = (std/core/set{@}(std/core/unique-count, (std/core/(+){@}(u, 1))));;
      u
    }))
  };
// Join a list of strings with newlines
public fun unlines : (xs : list<string>) -> string
  = fun(xs:list<string>){
    std/core/join.3{0,2,fast}(xs, "\n")
  };
// _unsafe_. The cancelation exception. User code should never throw
// this exception as it cannot be caught (but it is respected by `finally` blocks).
// It is used internally to `finalize` effect handlers that do not resume.
public fun unsafe-cancel-exn : () -> exception
  = fun(){
    std/core/exception{0,2,fast}("computation is canceled", std/core/Cancel)
  };
// _Unsafe_. This function removes the non-termination effect (`:div`) from the effect of an action
public fun* (.bind-unsafe-nodiv) : forall<a,e> (action : () -> <div|e> a) -> e a
  = forall<a,e> fun<e>(action:() -> <div|e> a){
    std/core/unsafe-total{2,1,fast}(action)
  };
// _Unsafe_. This function removes the non-termination effect (`:div`) from the effect of an action
public fun (.fast-unsafe-nodiv) : forall<a,e> (action : () -> <div|e> a) -> e a
  = forall<a,e> fun<e>(action:() -> <div|e> a){
    std/core/unsafe-total{2,1,fast}(action)
  };
// _Unsafe_. This function removes the non-termination effect (`:div`) from the effect of an action
public fun** unsafe-nodiv : forall<a,e> (action : () -> <div|e> a) -> e a
  = forall<a,e> fun<e>(action:() -> <div|e> a){
    std/core/(.bind-unsafe-nodiv){2,1,bind}(action)
  };
// _unsafe_. Catch any exception, including a possible cancelation.
// Unsafe to use in general as you must guarantee to later use `untry` to re-throw
// at least a cancelation exception.
public fun* (.bind-unsafe-try-all) : forall<a,e> (action : () -> <exn|e> a) -> e try<a>
  = forall<a,e> fun<e>(action:() -> <exn|e> a){
    std/core/(.bind-prim-try-all){2,2,bind}((fun<<exn|e>>(){
        (std/core/bind{@}((action()), (fun<<exn|e>>(.y.298:a){
            (std/core/Ok(.y.298))
          })))
      }), (fun<e>(exception0:exception){
        (std/core/lift{@}((std/core/Exn(exception0))))
      }))
  };
// _unsafe_. Catch any exception, including a possible cancelation.
// Unsafe to use in general as you must guarantee to later use `untry` to re-throw
// at least a cancelation exception.
public fun (.fast-unsafe-try-all) : forall<a,e> (action : () -> <exn|e> a) -> e try<a>
  = forall<a,e> fun<e>(action:() -> <exn|e> a){
    std/core/(.fast-prim-try-all){2,2,fast}((fun<<exn|e>>(){
        (std/core/Ok((action())))
      }), std/core/Exn)
  };
// _unsafe_. Catch any exception, including a possible cancelation.
// Unsafe to use in general as you must guarantee to later use `untry` to re-throw
// at least a cancelation exception.
public fun** unsafe-try-all : forall<a,e> (action : () -> <exn|e> a) -> e try<a>
  = forall<a,e> fun<e>(action:() -> <exn|e> a){
    std/core/(.bind-unsafe-try-all){2,1,bind}(action)
  };
// Transform an `:try` type back to an `exn` effect.
public fun untry : forall<a> (ex : try<a>) -> exn a
  = forall<a> fun<exn>(ex:try<a>){
    match (ex) {
      std/core/Exn(exn) -> std/core/throw{1,1,fast}(exn)
      std/core/Ok(x) -> x
    }
  };
// Unzip a list of pairs into two lists
public fun unzip : forall<a,b> (xs : list<(a, b)>) -> (list<a>, list<b>)
  = forall<a,b> fun(xs:list<(a, b)>){
    val iter : forall<c,d> (list<(c, d)>, list<c>, list<d>) -> (list<c>, list<d>)
      = forall<c,d> fun(ys:list<(c, d)>, acc1:list<c>, acc2:list<d>){
        match (ys) {
          std/core/Cons(std/core/(,)(x, y), xx) -> iter(xx, (std/core/Cons(x, acc1)), (std/core/Cons(y, acc2)))
          std/core/Nil() -> std/core/(,)((std/core/reverse{1,1,fast}(acc1)), (std/core/reverse{1,1,fast}(acc2)))
        }
      };;
    iter(xs, std/core/Nil, std/core/Nil)
  };
// Convert a string to a vector of characters.
public fun vector .1 : (s : string) -> vector<char>
  = fun(s:string){
    std/core/(.extern-vector){@}(s)
  };
// Create a new vector of length `n`  with initial elements `default` .
public fun vector .2 : forall<a> (n : int, default : a) -> vector<a>
  = forall<a> fun(n:int, default0:a){
    std/core/vector-init32{1,2,fast}((std/core/int32{@}(n)), (fun(_i:int32){
        default0
      }))
  };
// Convert a list to a vector.
public fun vector .3 : forall<a> (xs : list<a>) -> vector<a>
  = forall<a> fun(xs:list<a>){
    std/core/(.extern-vector.1){@}(xs)
  };
// Create a new vector of length `n`  with initial elements given by function `f` .
public fun vector-init : forall<a> (n : int, f : (int) -> a) -> vector<a>
  = forall<a> fun(n:int, f:(int) -> a){
    std/core/vector-init32{1,2,fast}((std/core/int32{@}(n)), (fun(i:int32){
        (f((std/core/int.1{@}(i))))
      }))
  };
// The `while` fun executes `action`  as long as `pred`  is `true`.
public fun* (.bind-while) : forall<e> (predicate : () -> <div|e> bool, action : () -> <div|e> ()) -> <div|e> ()
  = forall<e> fun<<div|e>>(predicate:() -> <div|e> bool, action:() -> <div|e> ()){
    std/core/bind{@}((predicate()), (fun<<div|e>>(.y.301:bool){
        match (.y.301) {
          std/core/True() -> std/core/bind{@}((action()), (fun<<div|e>>(_:()){
              (std/core/(.bind-while){1,2,bind}(predicate, action))
            }))
          std/core/False() -> std/core/()
        }
      }))
  };
// The `while` fun executes `action`  as long as `pred`  is `true`.
public fun (.fast-while) : forall<e> (predicate : () -> <div|e> bool, action : () -> <div|e> ()) -> <div|e> ()
  = forall<e> fun<<div|e>>(predicate0:() -> <div|e> bool, action0:() -> <div|e> ()){
    match ((predicate0())) {
      std/core/True() -> val _0 : ()
                               = action0();
      std/core/(.fast-while){1,2,fast}(predicate0, action0)
      std/core/False() -> std/core/()
    }
  };
// The `while` fun executes `action`  as long as `pred`  is `true`.
public fun** while : forall<e> (predicate : () -> <div|e> bool, action : () -> <div|e> ()) -> <div|e> ()
  = forall<e> fun<<div|e>>(predicate1:() -> <div|e> bool, action1:() -> <div|e> ()){
    std/core/(.bind-while){1,2,bind}(predicate1, action1)
  };
// Tests if a character is an element of `" \t\n\r"`
public fun white? : (c : char) -> bool
  = fun(c:char){
    std/core/(||){@}((std/core/(==){@}(c, ' ')), (std/core/(||){@}((std/core/(==){@}(c, '\t')), (std/core/(||){@}((std/core/(==){@}(c, '\n')), (std/core/(==){@}(c, '\r')))))))
  };
// Is the value zero?
public fun zero? .1 : (d : double) -> bool
  = fun(d:double){
    std/core/(==.2){@}(d, 0.0)
  };
// Zip two lists together by apply a function `f` to all corresponding elements.
// The returned list is only as long as the smallest input list.
public fun* (.bind-zipwith) : forall<a,b,c,e> (xs : list<a>, ys : list<b>, f : (a, b) -> e c) -> e list<c>
  = forall<a,b,c,e> fun<e>(xs:list<a>, ys:list<b>, f:(a, b) -> e c){
    std/core/(.bind-zipwith-indexed){4,3,bind}(xs, ys, (fun<e>(i:int, x:a, y:b){
        (f(x, y))
      }))
  };
// Zip two lists together by apply a function `f` to all corresponding elements.
// The returned list is only as long as the smallest input list.
public fun (.fast-zipwith) : forall<a,b,c,e> (xs : list<a>, ys : list<b>, f : (a, b) -> e c) -> e list<c>
  = forall<a,b,c,e> fun<e>(xs:list<a>, ys:list<b>, f:(a, b) -> e c){
    std/core/(.fast-zipwith-indexed){4,3,fast}(xs, ys, (fun<e>(i:int, x:a, y:b){
        (f(x, y))
      }))
  };
// Zip two lists together by apply a function `f` to all corresponding elements.
// The returned list is only as long as the smallest input list.
public fun** zipwith : forall<a,b,c,e> (xs : list<a>, ys : list<b>, f : (a, b) -> e c) -> e list<c>
  = forall<a,b,c,e> fun<e>(xs:list<a>, ys:list<b>, f:(a, b) -> e c){
    std/core/(.bind-zipwith){4,3,bind}(xs, ys, f)
  };
// Add the divergent effect to a function effect.
public external inject-div : forall<a,e> (() -> e a) -> (() -> <div|e> a) = inline "#1";
// Add the divergent effect to a function effect.
public external inject-div .1 : forall<a,b,e> ((a) -> e b) -> ((a) -> <div|e> b) = inline "#1";
// Add the state effect to a function effect.
public external inject-st : forall<a,b,h,e> ((a) -> e b) -> total ((a) -> <st<h>|e> b) = inline "#1";
// Add the state effect to a function effect.
public external inject-st .1 : forall<a,h,e> (() -> e a) -> total (() -> <st<h>|e> a) = inline "#1";
external (.extern-info) : (exn : exception) -> exception-info {
  cs inline "Primitive.ExnInfo(#1)";
  js inline "exn_info(#1)";
}
external (.extern-stack-trace) : (exn : exception) -> string {
  cs inline "Primitive.ExnStackTrace(#1)";
  js inline "exn_stacktrace(#1)";
}
external (.extern-exception) : (message : string, info : exception-info) -> exception {
  cs inline "Primitive.ExnException(#1,#2)";
  js inline "exn_exception(#1,#2)";
}
external (.extern-throw) : forall<a> (exn : exception) -> exn a {
  cs inline "Primitive.Throw<##1>(#1)";
  js inline "exn_throw(#1)";
}
// Return the message associated with an exception
external (.extern-message) : (exn : exception) -> string {
  cs inline "Primitive.ExnMessage(#1)";
  js inline "exn_message(#1)";
}
// Raise a pattern match exception. This is function is used internally by the
// compiler to generate error messages on pattern match failures.
external (.extern-error-pattern) : forall<a> (location : string, definition : string) -> exn a {
  cs inline "Primitive.ExnErrorPattern<##1>(#1,#2)";
  js inline "exn_error_pattern(#1,#2)";
}
// Execute a `hndler` no matter what exception was raised in `action`.
external (.extern-finally) : forall<e,a> (action : () -> e a, hndl : () -> e ()) -> e a {
  cs inline "Eff.Op.HandleFinally<##2>(#1,#2)";
  js inline "$std_core._handle_finally(#1,#2)";
}
// Catch any exception raised in `action` and handle it.
// Use `on-exn` or `on-exit` when appropiate.
external (.extern-try) : forall<a,e> (action : () -> <exn|e> a, hndl : (exception) -> e a) -> e a {
  cs inline "Eff.Op.HandleCatch<##1>(#1,#2, false)";
  js inline "$std_core._handle_catch(#1, #2, false)";
}
external (.extern-prim-try-some) : forall<a,e> (action : () -> <exn|e> a, hndl : (exception) -> <exn|e> a) -> <exn|e> a {
  cs inline "Eff.Op.HandleCatch<##1>(#1,#2, false)";
  js inline "$std_core._handle_catch(#1, #2, false)";
}
external (.extern-prim-try-all) : forall<a,e> (action : () -> <exn|e> a, hndl : (exception) -> e a) -> e a {
  cs inline "Eff.Op.HandleCatch<##1>(#1,#2,true)";
  js inline "$std_core._handle_catch(#1,#2,true)";
}
// Unsafe: transform any type to a `null` type; used internally by the compiler.
external (.extern-null-any) : forall<a> (x : a) -> null<a> {
  cs inline "#1";
  js inline "(#1==null ? null : #1)";
}
// Transform a `:maybe` type to a `:null` type (using `null` for `Nothing`).
external (.extern-null) : forall<a> (x : maybe<a>) -> null<a> {
  cs inline "(#1.tag_ == __std_core._maybe_Tag.Nothing ? default(##1) : #1.@value)";
  js inline "(#1==null ? null : #1.value)";
}
// Transform a `:null` type to a `:maybe` type. Note that it is not
// always the case that `id(x) == maybe(null(x))` (e.g. when `x = Just(Nothing)`).
external (.extern-maybe) : forall<a> (n : null<a>) -> maybe<a> {
  cs inline "(EqualityComparer<##1>.Default.Equals(#1,default(##1)) ? __std_core._maybe<##1>.Nothing_ : new __std_core._maybe<##1>(#1))";
  js inline "(#1==null ? $std_core.Nothing : $std_core.Just(#1))";
}
external inject-st .2 : forall<a,b,c,h,e> ((a, b) -> e c) -> total ((a, b) -> <st<h>|e> c) = inline "#1";
public external (==) : (char, char) -> bool {
  inline "(#1 == #2)";
  js inline "(#1 === #2)";
}
public external (!=) : (char, char) -> bool {
  inline "(#1 != #2)";
  js inline "(#1 !== #2)";
}
public external (<=) : (char, char) -> bool = inline "(#1 <= #2)";
public external (>=) : (char, char) -> bool = inline "(#1 >= #2)";
public external (<) : (char, char) -> bool = inline "(#1 < #2)";
public external (>) : (char, char) -> bool = inline "(#1 > #2)";
// Convert a character to its unicode code point
public external int : (char) -> int {
  inline "#1";
  cs inline "new BigInteger(#1)";
}
// Convert a unicode code point to a character
public external char : (int) -> char {
  inline "(#1)";
  cs inline "Primitive.IntToInt32(#1)";
}
public external (&&) : (bool, bool) -> bool = inline "(#1 && #2)";
public external (||) : (bool, bool) -> bool = inline "(#1 || #2)";
public external not : (bool) -> bool = inline "!(#1)";
public external (!) : (bool) -> bool = inline "!(#1)";
// Compare two integers
public external compare : (int, int) -> order {
  cs inline "Primitive.IntCompare(#1,#2)";
  js inline "$std_core._int_compare(#1,#2)";
}
// Are two integers equal?
public external (==) .1 : (int, int) -> bool {
  cs inline "(#1 == #2)";
  js inline "$std_core._int_eq(#1,#2)";
}
// Are two integers not equal?
public external (!=) .1 : (int, int) -> bool {
  cs inline "(#1 != #2)";
  js inline "$std_core._int_ne(#1,#2)";
}
// Is the first integer smaller or equal to the second?
public external (<=) .1 : (int, int) -> bool {
  cs inline "(#1 <= #2)";
  js inline "$std_core._int_le(#1,#2)";
}
// Is the first integer greater or equal to the second?
public external (>=) .1 : (int, int) -> bool {
  cs inline "(#1 >= #2)";
  js inline "$std_core._int_ge(#1,#2)";
}
// Is the first integer smaller than the second?
public external (<) .1 : (int, int) -> bool {
  cs inline "(#1 < #2)";
  js inline "$std_core._int_lt(#1,#2)";
}
// Is the first integer greater than the second?
public external (>) .1 : (int, int) -> bool {
  cs inline "(#1 > #2)";
  js inline "$std_core._int_gt(#1,#2)";
}
// Add two integers.
public external (+) : (int, int) -> int {
  cs inline "(#1 + #2)";
  js inline "$std_core._int_add(#1,#2)";
}
// Substract two integers.
public external (-) : (int, int) -> int {
  cs inline "(#1 - #2)";
  js inline "$std_core._int_sub(#1,#2)";
}
// Multiply two integers.
public external (*) : (int, int) -> int {
  cs inline "(#1 * #2)";
  js inline "$std_core._int_mul(#1,#2)";
}
// Euclidean-0 division of two integers. See also `divmod:(x : int, y : int) -> (int,int)`.
public external (/) : (x : int, y : int) -> int {
  cs inline "Primitive.IntDiv(#1,#2)";
  js inline "$std_core._int_div(#1,#2)";
}
// Euclidean modulus of two integers; always a non-negative number. See also `divmod:(x : int, y : int) -> (int,int)`.
public external (%) : (int, int) -> int {
  cs inline "Primitive.IntMod(#1,#2)";
  js inline "$std_core._int_mod(#1,#2)";
}
// Euclidean-0 division & modulus.
// Euclidean division is defined as: For any `D`  and `d`  where `d!=0` , we have:
//
// 1. `D == d*(D/d) + (D%d)`
// 2. `D%d`  is always positive where `0 <= D%d < abs(d)`
//
// Moreover, Euclidean-0 is a total function, for the case where `d==0`  we have
// that `D%0 == D`  and `D/0 == 0` . So property (1) still holds, but not property (2).
//
// Useful laws that hold for Euclidean-0 division:
//
// * `D/(-d) == -(D/d)`
// * `D%(-d) == D%d`
// * `D/(2^n) == sar(D,n)         `  (with `0 <= n <= 31`  and `2^n`  means `2`  to the power of `n` )
// * `D%(2^n) == D & ((2^n) - 1)  `  (with `0 <= n <= 31`  and `2^n`  means `2`  to the power of `n` )
//
// See also _Division and modulus for computer scientists, Daan Leijen, 2001_ for further information
// available at: <http://research.microsoft.com/pubs/151917/divmodnote.pdf> .
public external divmod : (x : int, y : int) -> (int, int) {
  cs inline "Primitive.IntDivMod(#1,#2)";
  js inline "$std_core._int_divmod(#1,#2)";
}
// Negate an integer.
public external (~) : (i : int) -> int {
  cs inline "(-#1)";
  js inline "$std_core._int_negate(#1)";
}
// Convert an integer to a `:double`. May return `nan` if the integer is too large to represent as a `:double`.
public external double : (int) -> double {
  cs inline "Primitive.IntToDouble(#1)";
  js inline "$std_core._int_to_double(#1)";
}
// Is this an odd integer?
public external odd? : (int) -> bool {
  cs inline "!(#1.IsEven)";
  js inline "$std_core._int_isodd(#1)";
}
// Is this equal to zero?
public external zero? : (int) -> bool {
  cs inline "(#1.IsZero)";
  js inline "$std_core._int_iszero(#1)";
}
// Return the absolute value of an integer.
public external abs : (i : int) -> int {
  cs inline "BigInteger.Abs(#1)";
  js inline "$std_core._int_abs(#1)";
}
// Raise an integer `i` to the power of `exp`.
external (.extern-pow) : (i : int, exp : int) -> int {
  cs inline "Primitive.IntPow(#1,#2)";
  js inline "_int_pow(#1,#2)";
}
// Return the number of ending `0` digits of `i`. Return `0` when `i==0`.
external (.extern-exp10?) : (i : int) -> int {
  cs inline "Primitive.IntCountPow10(#1)";
  js inline "_int_count_pow10(#1)";
}
// Return the number of decimal digits of `i`. Return `0` when `i==0`.
external (.extern-count-digits) : (i : int) -> int {
  cs inline "Primitive.IntCountDigits(#1)";
  js inline "_int_count_digits(#1)";
}
external (.extern-mul-exp10) : (i : int, n : int) -> int {
  cs inline "Primitive.IntMulPow10(#1,#2)";
  js inline "_int_mul_pow10(#1,#2)";
}
external (.extern-cdiv-exp10) : (i : int, n : int) -> int {
  cs inline "Primitive.IntCDivPow10(#1,#2)";
  js inline "_int_cdiv_pow10(#1,#2)";
}
public external sign : (i : int) -> order {
  cs inline "Primitive.IntSign(#1)";
  js inline "$std_core._int_sign(#1)";
}
// Convert an `:int32` to an `:int`.
public external int .1 : (i : int32) -> int {
  cs inline "(new BigInteger(#1))";
  js inline "$std_core._int_double(#1)";
}
// Convert an integer to an `:int32`. The number is _clamped_ to the maximal or minimum `:int32`
// value if it is outside the range of an `:int32`.
public external int32 : (int) -> int32 {
  cs inline "Primitive.IntToInt32(#1)";
  js inline "$std_core._int_to_int32(#1)";
}
// Minimal set of operations that we need in `std/core`.
external (<=) .2 : (int32, int32) -> bool {
  inline "(#1 <= #2)";
  js inline "(#1 <= #2)";
}
external (<) .2 : (int32, int32) -> bool {
  inline "(#1 < #2)";
  js inline "(#1 < #2)";
}
external (+) .1 : (int32, int32) -> int32 {
  inline "(#1 + #2)";
  js inline "((#1 + #2)|0)";
}
external (-) .1 : (int32, int32) -> int32 {
  inline "(#1 - #2)";
  js inline "((#1 - #2)|0)";
}
external pos? : (i : int32) -> bool = inline "(#1>0)";
external neg? : (i : int32) -> bool = inline "(#1<0)";
external (.extern-xparse-int) : (s : string, hex : bool) -> maybe<int> {
  cs inline "Primitive.IntParse(#1,#2)";
  js inline "_int_parse(#1,#2)";
}
public external (==) .2 : (double, double) -> bool {
  inline "(#1 == #2)";
  js inline "(#1 === #2)";
}
public external (!=) .2 : (double, double) -> bool {
  inline "(#1 != #2)";
  js inline "(#1 !== #2)";
}
public external (<=) .3 : (double, double) -> bool = inline "(#1 <= #2)";
public external (>=) .2 : (double, double) -> bool = inline "(#1 >= #2)";
public external (<) .3 : (double, double) -> bool = inline "(#1 < #2)";
public external (>) .2 : (double, double) -> bool = inline "(#1 > #2)";
public external (+) .2 : (double, double) -> double = inline "(#1 + #2)";
public external (-) .2 : (double, double) -> double = inline "(#1 - #2)";
public external (*) .1 : (double, double) -> double = inline "(#1 * #2)";
public external (/) .1 : (double, double) -> double = inline "(#1 / #2)";
public external (%) .1 : (double, double) -> double = inline "(#1 % #2)";
// Negate a `:double`.
public external (~) .1 : (d : double) -> double = inline "(-#1)";
// convert a `:double` to an `:int` using `round` to round to its nearest integer.
// (rounding to an even number on a tie)
// Returns `0` if the argument is not `finite?`.
public external int .2 : (d : double) -> int {
  cs inline "Primitive.IntDouble(#1)";
  js inline "$std_core._int_double(#1)";
}
// Returns the value `d`  raised to the power `p` .
public external (^) : (d : double, p : double) -> double {
  cs inline "Math.Pow(#1,#2)";
  js inline "Math.pow(#1,#2)";
}
// Return the absolute value of a `:double` `d`
public external abs .1 : (d : double) -> double {
  cs inline "Math.Abs(#1)";
  js inline "Math.abs(#1)";
}
// Convert a character to a string
external (.extern-string) : (c : char) -> string {
  cs inline "Primitive.CharToString(#1)";
  js inline "_char_to_string(#1)";
}
// Convert a vector of characters to a string.
external (.extern-string) .1 : (vector<char>) -> string {
  cs inline "Primitive.CharsToString(#1)";
  js inline "_chars_to_string(#1)";
}
// Convert a string to a vector of characters.
external (.extern-vector) : (s : string) -> vector<char> {
  cs inline "Primitive.StringToChars(#1)";
  js inline "_string_to_chars(#1)";
}
// Convert a string to a list of characters
external (.extern-list) : (s : string) -> total list<char> {
  cs inline "Primitive.StringToList(#1)";
  js inline "_string_to_list(#1)";
}
// Convert a list of characters to a string
external (.extern-string) .2 : (cs : list<char>) -> total string {
  cs inline "Primitive.ListToString(#1)";
  js inline "_list_to_string(#1)";
}
// Are two strings equal?
// Uses exact equality between character codes.
public external (==) .3 : (string, string) -> bool {
  inline "(#1 == #2)";
  js inline "(#1 === #2)";
}
// Are two strings not equal?
public external (!=) .3 : (string, string) -> bool {
  inline "(#1 != #2)";
  js inline "(#1 !== #2)";
}
external (.extern-string-compare) : (x : string, y : string) -> int {
  cs inline "String.Compare(#1,#2)";
  js inline "(#1===#2 ? 0 : (#1 > #2 ? 1 : -1))";
}
// Append two strings.
public external (+) .3 : (string, string) -> string = inline "(#1 + #2)";
// Length returns the length in the platform specific encoding (and should not be exported)
external length : (s : string) -> int32 {
  cs inline "#1.Length";
  js inline "#1.length";
}
// O(n). Return the number of characters in a string.
external (.extern-count) : (s : string) -> int {
  cs inline "Primitive.StringCount(#1)";
  js inline "_string_count(#1)";
}
// O(n). Return the number of characters in a string slice
external (.extern-count) .1 : (slice : sslice) -> int {
  cs inline "Primitive.SliceCount(#1)";
  js inline "_sslice_count(#1)";
}
external first1 : (s : string) -> sslice {
  cs inline "Primitive.SliceFirst(#1)";
  js inline "_sslice_first(#1)";
}
external last1 : (s : string) -> sslice {
  cs inline "Primitive.SliceLast(#1)";
  js inline "_sslice_last(#1)";
}
// Return the common prefix of two strings (upto `upto` characters (default is minimum length of the two strings))
external (.extern-common-prefix) : (s : string, t : string, upto : int) -> sslice {
  cs inline "Primitive.SliceCommonPrefix(#1,#2,#3)";
  js inline "_sslice_common_prefix(#1,#2,#3)";
}
// O(`count`). Advance the start position of a string slice by `count` characters
// up to the end of the string.
// A negative `count` advances the start position backwards upto the first position
// in a string.
// Maintains the character count of the original slice upto the end of the string.
// For example:
//
// * `"abc".first.advance(1).string == "b"`,
// * `"abc".first.advance(3).string == ""`,
// * `"abc".last.advance(-1).string == "b"`.
//
external (.extern-advance) : (slice : sslice, count : int) -> sslice {
  cs inline "Primitive.SliceAdvance(#1,#2)";
  js inline "_sslice_advance(#1,#2)";
}
// O(`count`). Extend a string slice by `count` characters up to the end of the string.
// A negative `count` shrinks the slice up to the empty slice.
// For example:
//
// * `"abc".first.extend(1).string == "ab"`
// * `"abc".last.extend(-1).string == ""`
//
external (.extern-extend) : (slice : sslice, count : int) -> sslice {
  cs inline "Primitive.SliceExtend(#1,#2)";
  js inline "_sslice_extend(#1,#2)";
}
// O(n). Copy the `slice` argument into a fresh string.
// Takes O(1) time if the slice covers the entire string.
external (.extern-string) .3 : (slice : sslice) -> string {
  cs inline "Primitive.SliceToString(#1)";
  js inline "_slice_to_string(#1)";
}
// If the slice is not empty,
// return the first character, and a new slice that is advanced by 1.
external (.extern-next) : (slice : sslice) -> maybe<(char, sslice)> {
  cs inline "Primitive.SliceNext(#1)";
  js inline "_sslice_next(#1)";
}
// Does string `s`  contain the string `sub`  ?
external xindex-of : (s : string, sub : string) -> int32 {
  cs inline "((#1).IndexOf(#2))";
  js inline "((#1).indexOf(#2))";
}
// Does string `s`  contain the string `sub`  ?
external xlast-index-of : (s : string, sub : string) -> int32 {
  cs inline "(#1.LastIndexOf(#2))";
  js inline "((#1).lastIndexOf(#2))";
}
external xstarts-with : (s : string, pre : string) -> bool {
  cs inline "#1.StartsWith(#2)";
  js inline "(#1.substr(0,#2.length) === #2)";
}
external (.extern-xends-with) : (s : string, post : string) -> bool {
  cs inline "#1.EndsWith(#2)";
  js inline "((#1).indexOf(#2, (#1).length - (#2).length) !== -1)";
}
// Does string `s`  contain the string `sub`  ?
public external contains : (s : string, sub : string) -> bool {
  cs inline "((#1).Contains(#2))";
  js inline "((#1).indexOf(#2) >= 0)";
}
// Concatenate a vector of strings
public external join : (v : vector<string>) -> string {
  cs inline "String.Concat(#1)";
  js inline "((#1).join(''))";
}
// Concatenate a vector of strings with a separator `sep`
public external join .1 : (v : vector<string>, sep : string) -> total string {
  cs inline "Primitive.Concat(#1,#2)";
  js inline "((#1).join(#2))";
}
external (.extern-repeat32) : (s : string, n : int32) -> string {
  cs inline "Primitive.Repeat(#1,#2)";
  js inline "_string_repeat(#1,#2)";
}
external splitv : (s : string, sep : string) -> vector<string> {
  cs inline "(#1.Split(new String[]{#2}, StringSplitOptions.None))";
  js inline "((#1).split(#2))";
}
external splitv .1 : (s : string, sep : string, n : int32) -> vector<string> {
  cs inline "#1.Split(new String[]{#2},#3, StringSplitOptions.None)";
  js inline "(#1).split(#2, #3)";
}
// Replace every occurrence of `pattern` to `repl` in a string.
public external replace-all : (s : string, pattern : string, repl : string) -> string {
  cs inline "(#1).Replace(#2,#3)";
  js inline "(#1).replace(new RegExp((#2).replace(/[\\\\\\$\\^*+\\-{}?().]/g,'\\\\$&'),'g'),#3)";
}
// Count occurences of `pattern` in a string.
public external count : (s : string, pattern : string) -> int {
  cs inline "Primitive.Count(#1,#2)";
  js inline "((#2) ? ((#1).match(new RegExp((#2).replace(/[\\\\\\$\\^*+\\-{}?().]/g,'\\\\$&'),'g'))||[]).length : 0)";
}
// Convert a string to upper-case
external (.extern-to-upper) : (s : string) -> string {
  cs inline "(#1).ToUpper()";
  js inline "(#1).toUpperCase()";
}
// Convert a string to lower-case
external (.extern-to-lower) : (s : string) -> string {
  cs inline "(#1).ToLower()";
  js inline "(#1).toLowerCase()";
}
// Trim the starting white space of a string
public external trim-left : (s : string) -> string {
  cs inline "(#1).TrimStart()";
  js inline "((#1).replace(/^\\s\\s*/,''))";
}
// Trim the ending white space of a string.
public external trim-right : (s : string) -> string {
  cs inline "(#1).TrimEnd()";
  js inline "((#1).replace(/\\s+$/,''))";
}
// Return the element at position `index`  in vector `v` . Raise an out of bounds exception if `index < 0`  or `index >= v.length` .
external unsafe-idx : forall<a> (v : vector<a>, index : int32) -> total a {
  cs inline "(#1)[#2]";
  js inline "(#1)[#2]";
}
external unsafe-assign : forall<a> (v : vector<a>, i : int32, x : a) -> total () {
  cs inline "(#1)[#2] = #3";
  js inline "(#1)[#2] = #3";
}
external unsafe-vector : forall<a> (n : int32) -> total vector<a> {
  cs inline "(new ##1[#1])";
  js inline "Array(#1)";
}
// Return the element at position `index`  in vector `v` . Raise an out of bounds exception if `index < 0`  or `index >= v.length` .
public external [] : forall<a> (v : vector<a>, index : int) -> exn a {
  cs inline "(#1)[Primitive.IntToInt32(#2)]";
  js inline "$std_core._vector_at(#1,#2)";
}
external length32 : forall<a> (v : vector<a>) -> int32 {
  cs inline "((#1).Length)";
  js inline "((#1).length)";
}
// Create a new vector of length `n`  with initial elements given by function `f` .
external (.extern-vector-init32) : forall<a> (n : int32, f : (int32) -> a) -> vector<a> {
  cs inline "Primitive.NewArray<##1>(#1,#2)";
  js inline "_vector(#1,#2)";
}
// Create an empty vector.
public external vector : forall<a> () -> vector<a> {
  cs inline "new ##1[0]";
  js inline "[]";
}
// Convert a vector to a list with an optional tail.
external (.extern-vlist) : forall<a> (v : vector<a>, tail : list<a>) -> list<a> {
  cs inline "Primitive.VList<##1>(#1,#2)";
  js inline "_vlist(#1,#2)";
}
// Convert a list to a vector.
external (.extern-vector) .1 : forall<a> (xs : list<a>) -> vector<a> {
  cs inline "Primitive.UnVList<##1>(#1)";
  js inline "_unvlist(#1)";
}
// Generic show: shows the internal representation of an object as a string
// Note: this breaks parametricity so it should not be public
external (.extern-gshow) : forall<a> (a) -> string {
  cs inline "#1.ToString()";
  js inline "#1.toString()";
}
// Generic formatting
external gformat : forall<a> (value : a, format : string) -> string {
  cs inline "#1.ToString(#2,CultureInfo.InvariantCulture)";
  js inline "_gformat(#1, #2)";
}
external (.extern-int-show-hex) : (i : int, use-capitals : bool) -> string {
  cs inline "Primitive.IntShowHex(#1,#2)";
  js inline "_int_showhex(#1,#2)";
}
external (.extern-show-fixedx) : (d : double, prec : int32) -> string {
  cs inline "Primitive.DoubleShowFixed(#1,#2)";
  js inline "_double_show_fixed(#1,#2)";
}
external (.extern-show-expx) : (d : double, prec : int32) -> string {
  cs inline "Primitive.DoubleShowExp(#1,#2)";
  js inline "_double_show_exp(#1,#2)";
}
// Print a string to the console, including a final newline character.
external (.extern-xprintsln) : (string) -> console () {
  cs inline "Console.WriteLine(#1)";
  js inline "_println(#1)";
}
// Print a string to the console
external (.extern-xprints) : (string) -> console () {
  cs inline "Console.Write(#1)";
  js inline "_print(#1)";
}
external (.extern-xtrace) : (message : string) -> () {
  cs inline "Primitive.Trace(#1)";
  js inline "_trace(#1)";
}
external (.extern-xtrace-any) : forall<a> (message : string, x : a) -> () {
  cs inline "Primitive.TraceAny<##1>(#1,#2)";
  js inline "_trace_any(#1,#2)";
}
// Used by the compiler to wrap main console applications
external (.extern-main-console) : forall<a,e> (main : () -> e a) -> e a {
  cs inline "Primitive.MainConsole<##1>(#1)";
  js inline "(#1)()";
}
// Allocate a fresh reference with an initial value.
public external ref : forall<h,a> (value : a) -> (alloc<h>) ref<h,a> {
  cs inline "new Ref<##1,##2>(#1)";
  js inline "{ value: #1 }";
}
// Assign a new value to a reference.
public external set : forall<h,a> (ref : ref<h,a>, assigned : a) -> (write<h>) () {
  cs inline "#1.Set(#2)";
  js inline "((#1).value = #2)";
}
// Read the value of reference.
public external (!) .1 : forall<h,a,e> (ref : ref<h,a>) -> <read<h>|e> a with hdiv<h,a,e> {
  cs inline "#1.Value";
  js inline "((#1).value)";
}
// If a heap effect is unobservable, the heap effect can be erased by using the `run` fun.
// See also: _State in Haskell, by Simon Peyton Jones and John Launchbury_.
public external run : forall<e,a> (action : forall<h> () -> <st<h>|e> a) -> e a {
  cs inline "Primitive.Run<##2>(#1)";
  js inline "((#1)())";
}
external unsafe-total-cast : forall<e,a> (action : () -> e a) -> (() -> total a) = inline "#1";
// _Unsafe_. Mark a function parameter as decreasing to suppress the non-termination effect (`:div`).
public external unsafe-decreasing : forall<a> (x : a) -> a = inline "#1";
// Return a random number equal or larger than 0.0 and smaller than 1.0
external (.extern-random) : () -> ndet double {
  cs inline "Primitive.RandomDouble()";
  js inline "Math.random()";
}
// Return a positive random integer (including 0)
external (.extern-random-int) : () -> ndet int {
  cs inline "Primitive.RandomInt()";
  js inline "Math.floor(Math.random()*_max_precise)";
}
// Return the host environment: `dotnet`, `browser`, `webworker`, or `node`.
external (.extern-host) : () -> ndet string {
  cs inline "\"dotnet\"";
  js inline "_host";
}
external (.extern-inject-exn) : forall<a,e> (action : () -> e a) -> <exn|e> a {
  js inline "$std_core._handle_inject_exn(#1)";
}
public external (.inject-effect) : forall<a,e,e1> (effect-name : string, action : () -> e a) -> e1 a {
  js inline "$std_core._handle_inject(#1,0,#2)";
}
public external (.inject-resource) : forall<a,e> (effect-name : string, resource-tag : int, action : () -> e a) -> e a {
  js inline "$std_core._handle_inject(#1,#2,#3)";
}
public external bind : forall<a,b,e> (x : yld<a>, next : (a) -> e yld<b>) -> e yld<b> {
  cs inline "Eff.Op.Bind<##1,##2>(#1,#2)";
  js inline "$std_core._bind(#1,#2)";
}
external (.extern-yieldop) : forall<a,b> (effect-name : string, op-name : string, op-resource : int, op-idx : int, op : a) -> yld<b> {
  cs inline "Eff.Op.YieldOp<##1,##2>(#1,#2,(int)#4,#5)";
  js inline "$std_core._yield_op(#1,#2,#5,#4,#3)";
}
external (.extern-yieldop-x1) : forall<a,b,c> (effect-name : string, op-name : string, op-resource : int, op-idx : int, op : a, def : maybe<c>) -> yld<b> {
  cs inline "Eff.Op.YieldOpX1<##1,##2,##3>(#1,#2,(int)#4,#5)";
  js inline "$std_core._yield_op(#1,#2,#5,#4,#3)";
}
external (.extern-resume) : forall<a,b,e> (context : resume-context<a,e,b>, result : a) -> e b {
  js inline "#1.resume(#2,undefined)";
}
external (.extern-resume) .1 : forall<a,b,e,c> (context : resume-context1<a,e,b,c>, result : a, local : c) -> e b {
  js inline "#1.resume(#2,#3)";
}
external (.extern-finalize) : forall<a,b,c,e> (context : resume-context<a,e,b>, result : c) -> e c {
  js inline "#1.finalize(#2)";
}
external (.extern-finalize) .1 : forall<a,b,c,e,d> (context : resume-context1<a,e,b,d>, result : c) -> e c {
  js inline "#1.finalize(#2)";
}
external (.extern-makeHandlerBranch0) : forall<a,b,c,e> (resume-kind : int, op-name : string, branch : (resume-context<a,e,b>, op : c) -> e b) -> total handler-branch0<e,b> {
  cs inline "new Eff.Branch<##3,##1,##2>((Eff.ResumeKind)((int)#1),#2,#3)";
  js inline "$std_core._new_branch(#1,#2,#3)";
}
external (.extern-makeHandlerBranch1) : forall<a,b,c,e,d> (resume-kind : int, op-name : string, branch : (resume-context1<a,e,b,d>, op : c, local : d) -> e b) -> total handler-branch1<e,d,b> {
  cs inline "new Eff.Branch1<##5,##3,##1,##2>((Eff.ResumeKind)((int)#1),#2,#3)";
  js inline "$std_core._new_branch1(#1,#2,#3)";
}
external (.extern-makeHandlerBranch0-x1) : forall<a,e> (resume-kind : int, op-name : string, branch : any) -> total handler-branch0<e,a> {
  cs inline "new Eff.BranchX1<##1>((Eff.ResumeKind)((int)#1),#2,(TypeFun1)#3)";
  js inline "$std_core._new_branch(#1,#2,#3)";
}
external (.extern-makeHandlerBranch1-x1) : forall<a,e,b> (resume-kind : int, op-name : string, branch : any) -> total handler-branch1<e,b,a> {
  cs inline "new Eff.Branch1X1<##3,##1>((Eff.ResumeKind)((int)#1),#2,(TypeFun1)#3)";
  js inline "$std_core._new_branch1(#1,#2,#3)";
}
external (.extern-makeHandler0) : forall<a,b,e,e1> (effect-name : string, reinit : null<() -> e ()>, ret : null<(a) -> e b>, final : null<() -> e ()>, branches : vector<handler-branch0<e,b>>, handler-kind : int) -> total ((action : () -> e1 a) -> e b) {
  cs inline "Eff.Handler0<##1,##2>.Create(#1,#2,#3,(Eff.HandlerKind)((int)#4))";
  js inline "$std_core._new_handler(#1,#2,#3,#4,#5,#6)";
}
external (.extern-makeHandler1) : forall<a,b,e,c,e1> (effect-name : string, reinit : null<(local : c) -> e c>, ret : null<(result : a, local : c) -> e b>, final : null<(local : c) -> e ()>, branches : vector<handler-branch1<e,c,b>>, handler-kind : int) -> total ((initial-local : c, action : () -> e1 a) -> e b) {
  cs inline "Eff.Handler1<##4,##1,##2>.Create(#1,#2,#3,(Eff.HandlerKind)((int)#4))";
  js inline "$std_core._new_handler1(#1,#2,#3,#4,#5,#6)";
}
external (.extern-makeResourceHandler0) : forall<a,b,e,e1> (effect-name : string, reinit : null<() -> e ()>, ret : null<(a) -> e b>, final : null<() -> e ()>, branches : vector<handler-branch0<e,b>>, handler-kind : int, resource-tag : int) -> total ((action : () -> e1 a) -> e b) {
  cs inline "Eff.Handler0<##1,##2>.Create(#1,#2,#3,(Eff.HandlerKind)((int)#4))";
  js inline "$std_core._new_resource_handler(#1,#2,#3,#4,#5,#6,#7)";
}
external (.extern-makeResourceHandler1) : forall<a,b,e,c,e1> (effect-name : string, reinit : null<(local : c) -> e c>, ret : null<(result : a, local : c) -> e b>, final : null<(local : c) -> e ()>, branches : vector<handler-branch1<e,c,b>>, handler-kind : int, resource-tag : int) -> total ((initial-local : c, action : () -> e1 a) -> e b) {
  cs inline "Eff.Handler1<##4,##1,##2>.Create(#1,#2,#3,(Eff.HandlerKind)((int)#4))";
  js inline "$std_core._new_resource_handler1(#1,#2,#3,#4,#5,#6,#7)";
}
external (.extern-makeFreshResourceHandler0) : forall<a,b,c,e,e1> (effect-name : string, reinit : null<() -> e ()>, ret : null<(a) -> e b>, final : null<() -> e ()>, branches : vector<handler-branch0<e,b>>, handler-kind : int, resource-tag : int, resource-wrap : (int) -> c) -> total ((action : (c) -> e1 a) -> e b) {
  cs inline "Eff.Handler0<##1,##2>.Create(#1,#2,#3,(Eff.HandlerKind)((int)#4))";
  js inline "$std_core._new_resource_handler(#1,#2,#3,#4,#5,#6,#7,#8)";
}
external (.extern-makeFreshResourceHandler1) : forall<a,b,c,e,d,e1> (effect-name : string, reinit : null<(local : d) -> e d>, ret : null<(result : a, local : d) -> e b>, final : null<(local : d) -> e ()>, branches : vector<handler-branch1<e,d,b>>, handler-kind : int, resource-tag : int, resource-wrap : (int) -> c) -> total ((initial-local : d, action : (c) -> e1 a) -> e b) {
  cs inline "Eff.Handler1<##4,##1,##2>.Create(#1,#2,#3,(Eff.HandlerKind)((int)#4))";
  js inline "$std_core._new_resource_handler1(#1,#2,#3,#4,#5,#6,#7,#8)";
}
// Used for handlers with just a `return` branch
external (.extern-makeHandlerRet0) : forall<a,b,e> (ignored-effect-name : string, reinit : null<() -> e ()>, ret : null<(result : a) -> e b>, final : null<() -> e ()>, ignored-branches : int, ignored-kind : int) -> total ((action : () -> e a) -> e b) {
  js inline "$std_core._new_empty_handler(#2,#3,#4)";
}
// Used for handlers with just a `return` branch
external (.extern-makeHandlerRet1) : forall<a,b,e,c> (ignored-effect-name : string, reinit : null<(local : c) -> e c>, ret : null<(result : a, local : c) -> e b>, final : null<(local : c) -> e ()>, ignored-branches : int, ignored-kind : int) -> total ((local : c, action : () -> e a) -> e b) {
  js inline "$std_core._new_empty_handler1(#2,#3,#4)";
}
// .open is used in the compiler to open up closed effects.
// Usually simplified away but still present if --no-simplify flag is given
public external (.open) : forall<a,b> (x : a) -> total b = inline "#1";
// Magic casting to the `:any` type.
public external (.toany) : forall<a> (x : a) -> any {
  inline "#1";
  cs inline "(object)(#1)";
}